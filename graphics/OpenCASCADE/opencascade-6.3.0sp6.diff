diff -Naur OpenCASCADE6.3.0/ros/config.h.in OpenCASCADE6.3.0sp6/ros/config.h.in
--- OpenCASCADE6.3.0/ros/config.h.in	2008-09-02 11:27:00.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/config.h.in	2009-05-29 09:01:37.000000000 +0200
@@ -87,6 +87,9 @@
 /* Define to 1 if you have the <libc.h> header file. */
 #undef HAVE_LIBC_H
 
+/* Define to 1 if you have the `dl' library (-ldl). */
+#undef HAVE_LIBDL
+
 /* Define to 1 if you have the `pthread' library (-lpthread). */
 #undef HAVE_LIBPTHREAD
 
diff -Naur OpenCASCADE6.3.0/ros/configure.in OpenCASCADE6.3.0sp6/ros/configure.in
--- OpenCASCADE6.3.0/ros/configure.in	2008-09-09 17:49:10.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/configure.in	2009-05-29 09:01:37.000000000 +0200
@@ -67,6 +67,12 @@
 CSF_ThreadLibs_LIB=-lpthread
 AC_SUBST(CSF_ThreadLibs_LIB)
 
+#-----------------------------------------------------------------------------
+# dl library is required
+#-----------------------------------------------------------------------------
+AC_CHECK_LIB([dl],[dlopen],[],[AC_MSG_ERROR([dl library is required])])
+CSF_SOCKETLibs_LIB=-ldl
+
 #------------------------------------------------------------------------------
 # Get Tcl and TK configuration information from tclConfig.sh.
 #------------------------------------------------------------------------------
@@ -102,12 +108,15 @@
 		LDFLAGS="$LDFLAGS -lstdc++";;
 	SunOS*) CXXFLAGS="$CXXFLAGS -Usun -DSOLARIS -instances=static"
 		CFLAGS="$CFLAGS -Usun -DSOLARIS -instances=static"
-		LDFLAGS="$LDFLAGS -instances=static";;
+		LDFLAGS="$LDFLAGS -instances=static"
+		CSF_SOCKETLibs_LIB="-lnsl ${CSF_SOCKETLibs_LIB}";;
         OSF1*)  CXXFLAGS="$CXXFLAGS -DDECOSF1 -D__USE_STD_IOSTREAM -D_RWSTD_NO_EXCEPTIONS" 
                 CFLAGS="$CFLAGS -std1 -DDECOSF1"
 		LD=$CXX;;
 	*) ;;
 esac
+AC_SUBST(CSF_SOCKETLibs_LIB)
+
 AC_SUBST(platform)
 AC_LANG([C++])
 
@@ -370,32 +379,6 @@
 fi
 AM_CONDITIONAL( HAVE_GL, [test "xyes" = "x$HAVE_GL"] )
 
-#---------------------------------------------------------------------
-#
-# Check for DPS libraries
-#  
-#  
-#---------------------------------------------------------------------
-CSF_dpsLibs_INCLUDES="$X_INCLUDE"
-CSF_dpsLibs_LIB="$X_LIBS"
-if test "xno" = "x$HAVE_X11"; then
-  HAVE_DPS=no
-else
-  AC_CHECK_HEADER( [DPS/dpsXclient.h], [HAVE_DPS_INC=yes], [HAVE_DPS_INC=no] )
-  AC_CHECK_LIB( [dps], [DPSInitialize], [HAVE_DPS_LIB=yes], [HAVE_DPS_LIB=no] )
-  HAVE_DPS=yes
-  if test "xno" = "x$HAVE_DPS_INC"; then
-    HAVE_DPS=no
-    AC_MSG_NOTICE("Specify CPPFLAGS=-I<dps_include_dir> to enable DPS support")
-  fi
-  if test "xno" = "x$HAVE_DPS_LIB"; then
-    HAVE_DPS=no
-    AC_MSG_NOTICE("Specify LDFLAGS=-L<dps_lib_dir> to enable DPS support")
-  else
-    CSF_dpsLibs_LIB="$CSF_dpsLibs_LIB -ldps"
-  fi
-fi
-
 CFLAGS="$CFLAGS_save"
 CXXFLAGS="$CXXFLAGS_save"
 CPPFLAGS="$CPPFLAGS_save"
@@ -632,7 +615,6 @@
 AC_SUBST(LDFLAGS)
 
 
-CSF_SOCKETLibs_LIB=""
 CSF_XwLibs_LIB="$X_LIBS"
 
 AC_SUBST(CSF_SOCKETLibs_LIB)
diff -Naur OpenCASCADE6.3.0/ros/drv/BRepMesh/BRepMesh_FastDiscret.jxx OpenCASCADE6.3.0sp6/ros/drv/BRepMesh/BRepMesh_FastDiscret.jxx
--- OpenCASCADE6.3.0/ros/drv/BRepMesh/BRepMesh_FastDiscret.jxx	2008-09-09 17:59:57.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/drv/BRepMesh/BRepMesh_FastDiscret.jxx	2009-04-09 11:54:11.000000000 +0200
@@ -25,9 +25,6 @@
 #ifndef _BRepMesh_ListOfVertex_HeaderFile
 #include <BRepMesh_ListOfVertex.hxx>
 #endif
-#ifndef _TColStd_ListOfReal_HeaderFile
-#include <TColStd_ListOfReal.hxx>
-#endif
 #ifndef _BRepMesh_Classifier_HeaderFile
 #include <BRepMesh_Classifier.hxx>
 #endif
diff -Naur OpenCASCADE6.3.0/ros/drv/IntPatch/IntPatch_Intersection_0.cxx OpenCASCADE6.3.0sp6/ros/drv/IntPatch/IntPatch_Intersection_0.cxx
--- OpenCASCADE6.3.0/ros/drv/IntPatch/IntPatch_Intersection_0.cxx	2008-09-09 18:02:29.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/drv/IntPatch/IntPatch_Intersection_0.cxx	2009-04-09 11:54:18.000000000 +0200
@@ -75,6 +75,9 @@
 #ifndef _IntPatch_TheRLineOfIntersection_HeaderFile
 #include <IntPatch_TheRLineOfIntersection.hxx>
 #endif
+#ifndef _IntPatch_TheALineToWLineOfIntersection_HeaderFile
+#include <IntPatch_TheALineToWLineOfIntersection.hxx>
+#endif
 #ifndef _IntPatch_TheArcFunctionOfIntersection_HeaderFile
 #include <IntPatch_TheArcFunctionOfIntersection.hxx>
 #endif
@@ -144,9 +147,6 @@
 #ifndef _IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection_HeaderFile
 #include <IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection.hxx>
 #endif
-#ifndef _IntPatch_TheALineToWLineOfIntersection_HeaderFile
-#include <IntPatch_TheALineToWLineOfIntersection.hxx>
-#endif
 #ifndef _IntPatch_TheLineConstructorOfIntersection_HeaderFile
 #include <IntPatch_TheLineConstructorOfIntersection.hxx>
 #endif
@@ -192,6 +192,8 @@
 #define IntPatch_TheWLine_hxx <IntPatch_TheWLineOfIntersection.hxx>
 #define IntPatch_TheRLine IntPatch_TheRLineOfIntersection
 #define IntPatch_TheRLine_hxx <IntPatch_TheRLineOfIntersection.hxx>
+#define IntPatch_TheALineToWLine IntPatch_TheALineToWLineOfIntersection
+#define IntPatch_TheALineToWLine_hxx <IntPatch_TheALineToWLineOfIntersection.hxx>
 #define IntPatch_TheArcFunction IntPatch_TheArcFunctionOfIntersection
 #define IntPatch_TheArcFunction_hxx <IntPatch_TheArcFunctionOfIntersection.hxx>
 #define IntPatch_TheSOnBounds IntPatch_TheSOnBoundsOfIntersection
@@ -272,8 +274,6 @@
 #define IntPatch_ThePWalkingInterOfThePPInt_hxx <IntPatch_ThePWalkingInterOfThePPIntOfIntersection.hxx>
 #define IntPatch_PrmPrmIntersection_T3BitsOfThePPInt IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection
 #define IntPatch_PrmPrmIntersection_T3BitsOfThePPInt_hxx <IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection.hxx>
-#define IntPatch_TheALineToWLine IntPatch_TheALineToWLineOfIntersection
-#define IntPatch_TheALineToWLine_hxx <IntPatch_TheALineToWLineOfIntersection.hxx>
 #define IntPatch_TheLineConstructor IntPatch_TheLineConstructorOfIntersection
 #define IntPatch_TheLineConstructor_hxx <IntPatch_TheLineConstructorOfIntersection.hxx>
 #define Handle_IntPatch_SequenceNodeOfSequenceOfPoint Handle_IntPatch_SequenceNodeOfSequenceOfPointOfIntersection
diff -Naur OpenCASCADE6.3.0/ros/inc/Aspect_GraphicCallbackProc.hxx OpenCASCADE6.3.0sp6/ros/inc/Aspect_GraphicCallbackProc.hxx
--- OpenCASCADE6.3.0/ros/inc/Aspect_GraphicCallbackProc.hxx	2003-05-30 18:55:57.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/inc/Aspect_GraphicCallbackProc.hxx	2009-10-03 01:00:46.000000000 +0200
@@ -15,6 +15,13 @@
 #define OCC_REDRAW_WINDOWAREA 2
 #define OCC_REDRAW_BITMAP 3
 
+/* 
+   This flag, when bitwise OR`ed with the "reason" value, 
+   informs the callback that it is called before redrawing the overlayer .
+   Otherwise, the callback is invoked after the overlayer is redrawn.        
+*/
+#define OCC_PRE_OVERLAY 0x8000
+
  typedef struct {
    int reason;
    int wsID;
diff -Naur OpenCASCADE6.3.0/ros/inc/BRepFill_Sweep.hxx OpenCASCADE6.3.0sp6/ros/inc/BRepFill_Sweep.hxx
--- OpenCASCADE6.3.0/ros/inc/BRepFill_Sweep.hxx	2008-09-09 17:59:36.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/inc/BRepFill_Sweep.hxx	2009-10-03 01:00:51.000000000 +0200
@@ -28,6 +28,15 @@
 #ifndef _Standard_Real_HeaderFile
 #include <Standard_Real.hxx>
 #endif
+#ifndef _GeomFill_ApproxStyle_HeaderFile
+#include <GeomFill_ApproxStyle.hxx>
+#endif
+#ifndef _GeomAbs_Shape_HeaderFile
+#include <GeomAbs_Shape.hxx>
+#endif
+#ifndef _Standard_Integer_HeaderFile
+#include <Standard_Integer.hxx>
+#endif
 #ifndef _TopoDS_Shape_HeaderFile
 #include <TopoDS_Shape.hxx>
 #endif
@@ -52,15 +61,6 @@
 #ifndef _BRepFill_TransitionStyle_HeaderFile
 #include <BRepFill_TransitionStyle.hxx>
 #endif
-#ifndef _GeomFill_ApproxStyle_HeaderFile
-#include <GeomFill_ApproxStyle.hxx>
-#endif
-#ifndef _GeomAbs_Shape_HeaderFile
-#include <GeomAbs_Shape.hxx>
-#endif
-#ifndef _Standard_Integer_HeaderFile
-#include <Standard_Integer.hxx>
-#endif
 class BRepFill_LocationLaw;
 class BRepFill_SectionLaw;
 class TopTools_HArray2OfShape;
@@ -136,7 +136,7 @@
 //!    Degmax     : The maximum degree in v requiered on the surface <br>
 //!    Segmax     : The maximum number of span in v requiered on <br>
 //!                 the surface. <br>
-Standard_EXPORT   void Build(const BRepFill_TransitionStyle Transition = BRepFill_Modified,const GeomFill_ApproxStyle Approx = GeomFill_Location,const GeomAbs_Shape Continuity = GeomAbs_C2,const Standard_Integer Degmax = 10,const Standard_Integer Segmax = 30) ;
+Standard_EXPORT   void Build(const BRepFill_TransitionStyle Transition = BRepFill_Modified,const GeomFill_ApproxStyle Approx = GeomFill_Location,const GeomAbs_Shape Continuity = GeomAbs_C2,const Standard_Integer Degmax = 11,const Standard_Integer Segmax = 30) ;
 
 //! Say if the Shape is Build. <br>
 Standard_EXPORT   Standard_Boolean IsDone() const;
@@ -176,10 +176,13 @@
  // 
 
 
-Standard_EXPORT   Standard_Boolean BuildWire(const BRepFill_TransitionStyle Transition,const GeomFill_ApproxStyle Approx,const GeomAbs_Shape Continuity,const Standard_Integer Degmax,const Standard_Integer Segmax) ;
+Standard_EXPORT   Standard_Boolean CorrectApproxParameters() ;
+
+
+Standard_EXPORT   Standard_Boolean BuildWire(const BRepFill_TransitionStyle Transition) ;
 
 
-Standard_EXPORT   Standard_Boolean BuildShell(const BRepFill_TransitionStyle Transition,const Standard_Integer Vf,const Standard_Integer Vl,const GeomFill_ApproxStyle Approx,const GeomAbs_Shape Continuity,const Standard_Integer Degmax,const Standard_Integer Segmax,const Standard_Real ExtendFirst = 0.0,const Standard_Real ExtendLast = 0.0) ;
+Standard_EXPORT   Standard_Boolean BuildShell(const BRepFill_TransitionStyle Transition,const Standard_Integer Vf,const Standard_Integer Vl,const Standard_Real ExtendFirst = 0.0,const Standard_Real ExtendLast = 0.0) ;
 
 
 Standard_EXPORT   void PerformCorner(const Standard_Integer Index,const BRepFill_TransitionStyle Transition,const Handle(TopTools_HArray2OfShape)& Bounds) ;
@@ -204,6 +207,10 @@
 Standard_Real myTolAngular;
 Standard_Real myAngMin;
 Standard_Real myAngMax;
+GeomFill_ApproxStyle myApproxStyle;
+GeomAbs_Shape myContinuity;
+Standard_Integer myDegmax;
+Standard_Integer mySegmax;
 TopoDS_Shape myShape;
 Handle_BRepFill_LocationLaw myLoc;
 Handle_BRepFill_SectionLaw mySec;
diff -Naur OpenCASCADE6.3.0/ros/inc/BRepMesh_FastDiscret.hxx OpenCASCADE6.3.0sp6/ros/inc/BRepMesh_FastDiscret.hxx
--- OpenCASCADE6.3.0/ros/inc/BRepMesh_FastDiscret.hxx	2008-09-09 17:59:57.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/inc/BRepMesh_FastDiscret.hxx	2009-10-03 01:00:52.000000000 +0200
@@ -105,7 +105,6 @@
 class Geom2d_Curve;
 class TopoDS_Vertex;
 class BRepMesh_ListOfVertex;
-class TColStd_ListOfReal;
 class BRepMesh_Classifier;
 class TColStd_ListOfInteger;
 class BRepMesh_Delaun;
@@ -285,9 +284,6 @@
 Standard_EXPORT   void Add(const TopoDS_Vertex& theVert,const TopoDS_Face& face,const Handle(BRepAdaptor_HSurface)& S) ;
 
 
-Standard_EXPORT   void InternalVerticesForRectangle(const Handle(BRepAdaptor_HSurface)& caro,BRepMesh_ListOfVertex& inter,const TColStd_ListOfReal& u1pars,const TColStd_ListOfReal& u2pars,const TColStd_ListOfReal& v1pars,const TColStd_ListOfReal& v2pars) ;
-
-
 Standard_EXPORT   void InternalVertices(const Handle(BRepAdaptor_HSurface)& caro,BRepMesh_ListOfVertex& inter,const Standard_Real defedge,const BRepMesh_Classifier& classifier) ;
 
 
diff -Naur OpenCASCADE6.3.0/ros/inc/IntPatch_Intersection.hxx OpenCASCADE6.3.0sp6/ros/inc/IntPatch_Intersection.hxx
--- OpenCASCADE6.3.0/ros/inc/IntPatch_Intersection.hxx	2008-09-09 18:02:29.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/inc/IntPatch_Intersection.hxx	2009-10-03 01:02:19.000000000 +0200
@@ -85,6 +85,7 @@
 class IntPatch_TheALineOfIntersection;
 class IntPatch_TheWLineOfIntersection;
 class IntPatch_TheRLineOfIntersection;
+class IntPatch_TheALineToWLineOfIntersection;
 class IntPatch_TheArcFunctionOfIntersection;
 class IntPatch_TheSOnBoundsOfIntersection;
 class IntPatch_ThePathPointOfTheSOnBoundsOfIntersection;
@@ -108,7 +109,6 @@
 class IntPatch_TheInterfPolyhedronOfThePPIntOfIntersection;
 class IntPatch_ThePWalkingInterOfThePPIntOfIntersection;
 class IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection;
-class IntPatch_TheALineToWLineOfIntersection;
 class IntPatch_TheLineConstructorOfIntersection;
 class IntSurf_ListOfPntOn2S;
 class IntPatch_Line;
@@ -260,6 +260,8 @@
 #define IntPatch_TheWLine_hxx <IntPatch_TheWLineOfIntersection.hxx>
 #define IntPatch_TheRLine IntPatch_TheRLineOfIntersection
 #define IntPatch_TheRLine_hxx <IntPatch_TheRLineOfIntersection.hxx>
+#define IntPatch_TheALineToWLine IntPatch_TheALineToWLineOfIntersection
+#define IntPatch_TheALineToWLine_hxx <IntPatch_TheALineToWLineOfIntersection.hxx>
 #define IntPatch_TheArcFunction IntPatch_TheArcFunctionOfIntersection
 #define IntPatch_TheArcFunction_hxx <IntPatch_TheArcFunctionOfIntersection.hxx>
 #define IntPatch_TheSOnBounds IntPatch_TheSOnBoundsOfIntersection
@@ -340,8 +342,6 @@
 #define IntPatch_ThePWalkingInterOfThePPInt_hxx <IntPatch_ThePWalkingInterOfThePPIntOfIntersection.hxx>
 #define IntPatch_PrmPrmIntersection_T3BitsOfThePPInt IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection
 #define IntPatch_PrmPrmIntersection_T3BitsOfThePPInt_hxx <IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection.hxx>
-#define IntPatch_TheALineToWLine IntPatch_TheALineToWLineOfIntersection
-#define IntPatch_TheALineToWLine_hxx <IntPatch_TheALineToWLineOfIntersection.hxx>
 #define IntPatch_TheLineConstructor IntPatch_TheLineConstructorOfIntersection
 #define IntPatch_TheLineConstructor_hxx <IntPatch_TheLineConstructorOfIntersection.hxx>
 #define Handle_IntPatch_SequenceNodeOfSequenceOfPoint Handle_IntPatch_SequenceNodeOfSequenceOfPointOfIntersection
@@ -392,6 +392,8 @@
 #undef IntPatch_TheWLine_hxx
 #undef IntPatch_TheRLine
 #undef IntPatch_TheRLine_hxx
+#undef IntPatch_TheALineToWLine
+#undef IntPatch_TheALineToWLine_hxx
 #undef IntPatch_TheArcFunction
 #undef IntPatch_TheArcFunction_hxx
 #undef IntPatch_TheSOnBounds
@@ -472,8 +474,6 @@
 #undef IntPatch_ThePWalkingInterOfThePPInt_hxx
 #undef IntPatch_PrmPrmIntersection_T3BitsOfThePPInt
 #undef IntPatch_PrmPrmIntersection_T3BitsOfThePPInt_hxx
-#undef IntPatch_TheALineToWLine
-#undef IntPatch_TheALineToWLine_hxx
 #undef IntPatch_TheLineConstructor
 #undef IntPatch_TheLineConstructor_hxx
 #undef Handle_IntPatch_SequenceNodeOfSequenceOfPoint
diff -Naur OpenCASCADE6.3.0/ros/inc/IntPatch_PrmPrmIntersection.gxx OpenCASCADE6.3.0sp6/ros/inc/IntPatch_PrmPrmIntersection.gxx
--- OpenCASCADE6.3.0/ros/inc/IntPatch_PrmPrmIntersection.gxx	2008-07-18 16:59:37.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/inc/IntPatch_PrmPrmIntersection.gxx	2009-10-03 01:02:19.000000000 +0200
@@ -32,14 +32,14 @@
 				     Standard_Real& u2,
 				     Standard_Real& v2);
 
-//xf
+
 static 
   void AdjustOnPeriodic(const TheSurface& Surf1,
 			const TheSurface& Surf2,
 			IntPatch_SequenceOfLine& aSLin);
-//xt
+
 //==================================================================================
-// function : Constructor
+// function : 
 // purpose  : 
 //==================================================================================
 IntPatch_PrmPrmIntersection::IntPatch_PrmPrmIntersection(): done(Standard_False)
@@ -1677,8 +1677,7 @@
 	    }
 	  }
 	}
-	//--printf("\n\n1 Dist3[0]=%5.5g,u3[0]=%5.5g,v3[0]=%5.5g ,  Dist3[1]=%5.5g,u3[1]=%5.5g,v3[1]=%5.5g  ,Dist3[2]=%5.5g,u3[2]=%5.5g,v3[2]=%5.5g\n",
-	//--       Dist3[0],u3[0],v3[0] ,  Dist3[1],u3[1],v3[1]  ,Dist3[2],u3[2],v3[2]);
+	//
 	Standard_Real U1_3 = (u3[0]+u3[1]+u3[2])/3.0;
 	Standard_Real V1_3 = (v3[0]+v3[1]+v3[2])/3.0;
 	
@@ -1712,8 +1711,7 @@
 	    }
 	  }
 	}
-	//printf("\n2 Dist3[0]=%5.5g,u3[0]=%5.5g,v3[0]=%5.5g ,  Dist3[1]=%5.5g,u3[1]=%5.5g,v3[1]=%5.5g  ,Dist3[2]=%5.5g,u3[2]=%5.5g,v3[2]=%5.5g\n",
-	//       Dist3[0],u3[0],v3[0] ,  Dist3[1],u3[1],v3[1]  ,Dist3[2],u3[2],v3[2]);
+	//
 	Standard_Real U2_3 = (u3[0]+u3[1]+u3[2])/3.0;
 	Standard_Real V2_3 = (v3[0]+v3[1]+v3[2])/3.0;
 	
@@ -1725,7 +1723,6 @@
     }
   }
   while(ok);
-  //-- cout<<"\n *** "<<Compt<<" Points de *1  ** 2* ds la grille UVP"<<ComptTrouve<<endl; Compt=0;
 }
 
 //==================================================================================
@@ -1764,7 +1761,7 @@
     if (ClearFlag)
       SLin.Clear();
     // modified by NIZHNY-AMV  Tue Oct 18 12:37:02 2005.END
-
+    //
     //IntPolyh_Intersection Interference(Surf1,NbU1,NbV1,Surf2,NbU2,NbV2);
     //     IntPolyh_Intersection Interference(Surf1, anUpars1, aVpars1, 
     // 				       Surf2, anUpars2, aVpars2);
@@ -1775,15 +1772,16 @@
       pInterference = new IntPolyh_Intersection(Surf1,NbU1,NbV1,Surf2,NbU2,NbV2);
     }
     else {
-      pInterference = new IntPolyh_Intersection( Surf1, anUpars1, aVpars1, 
+      pInterference = new IntPolyh_Intersection(Surf1, anUpars1, aVpars1, 
 						Surf2, anUpars2, aVpars2 );
     }
     if ( !pInterference ) {
       done = Standard_False;
       return;
     }
+    //
     IntPolyh_Intersection& Interference = *pInterference;
-
+    //
     done = Interference.IsDone();
     if( !done ) {
       if ( pInterference ) {
@@ -1792,7 +1790,7 @@
       }
       return;
     }
-
+    
     Standard_Real Deflection2 = Deflection*Deflection;
     Standard_Integer nbLigSec = Interference.NbSectionLines();
     Standard_Integer nbTanZon = Interference.NbTangentZones();
@@ -1828,11 +1826,18 @@
 	  }
 	}
       } while(triok==Standard_False);
-
+      //
       for( ls = 1; ls <= nbLigSec; ls++) {
-	Standard_Integer nbp = Interference.NbPointsInLine(TabL[ls]);
-	Standard_Integer *TabPtDep = new Standard_Integer [nbp+1];
-	Standard_Integer ilig;
+	Standard_Integer nbp, ilig, *TabPtDep;
+	//
+	nbp = Interference.NbPointsInLine(TabL[ls]);
+	//modified by NIZNHY-PKV Fri Sep  5 15:19:28 2008f
+	if (!nbp) {
+	  continue;
+	}
+	//modified by NIZNHY-PKV Fri Sep  5 15:19:31 2008t
+	TabPtDep = new Standard_Integer [nbp+1];
+	//
 	for( ilig = 1; ilig <= nbp; ilig++ )
 	  TabPtDep[ilig]=0;
 
@@ -1864,9 +1869,8 @@
 	Standard_Integer nbps2 = (nbp>3)? (nbp/2) :  1;
 	Standard_Integer NombreDePointsDeDepartDuCheminement = 0;
 	Standard_Boolean lignetrouvee=Standard_False;
-	// const Standard_Integer NbDePointsDeDepartDuChmLimit = 3;
 	const Standard_Integer NbDePointsDeDepartDuChmLimit = 5;
-
+	//
 	do { 
 	  NombreDePointsDeDepartDuCheminement++;
 	  switch (NombreDePointsDeDepartDuCheminement) {
@@ -1891,7 +1895,7 @@
 	    nbps2 = NombreDePointsDeDepartDuCheminement-3;
 	    NombreDePointsDeDepartDuCheminement++;
 	  }
-
+	  //
 	  if(TabPtDep[nbps2] == 0) {
 	    TabPtDep[nbps2] = 1;
 	    Interference.GetLinePoint(TabL[ls],nbps2,_x,_y,_z,U1,V1,U2,V2,incidence);
@@ -1966,7 +1970,6 @@
 		Standard_Boolean bPWIsDone;
 		Standard_Integer iPWNbPoints, aNbPointsVer;
 		Standard_Real aD11, aD12, aD21, aD22, aDx;
-
 		//
 		bPWIsDone=PW.IsDone();
 		//xt
@@ -2023,12 +2026,8 @@
 			  }
 			}
 		      }
-// 		      if(Point3dDebut.Distance(verPointDebut.Value()) <= TolTangency) { 
-// 			if(Point3dFin.Distance(verPointFin.Value()) <= TolTangency)
-// 			  RejetLigne = Standard_True; 
-// 		      }
 		    }
-		    
+		    //
 		    if(!RejetLigne) {
 		      IntSurf_TypeTrans trans1,trans2;
 		      Standard_Real locu,locv;
@@ -2227,10 +2226,9 @@
       delete [] TabL;
 
     }// if nbLigSec >= 1
-
-    //xf
+    //
     AdjustOnPeriodic(Surf1, Surf2, SLin);
-    //xt
+    //
 
     //--------------------------------------------------------------------
     //-- Calcul des parametres approches a partir des Zones De Tangence --
diff -Naur OpenCASCADE6.3.0/ros/inc/InterfaceGraphic_tgl_all.h OpenCASCADE6.3.0sp6/ros/inc/InterfaceGraphic_tgl_all.h
--- OpenCASCADE6.3.0/ros/inc/InterfaceGraphic_tgl_all.h	2003-02-04 07:34:21.000000000 +0100
+++ OpenCASCADE6.3.0sp6/ros/inc/InterfaceGraphic_tgl_all.h	2009-10-03 01:02:23.000000000 +0200
@@ -9,11 +9,16 @@
 #ifndef  INTERFACEGRAPHIC_TGL_ALL_H
 #define  INTERFACEGRAPHIC_TGL_ALL_H
 
-typedef  int   Tint;
-typedef  float Tfloat;
-typedef  char  Tchar;
-typedef  char  Tbool;
-typedef unsigned int    Tuint;
+typedef  int          Tint;
+typedef  float        Tfloat;
+/* PCD 04/07/07  */
+typedef	 double       Tdouble;
+/* Tchar is treated as a signed char in visualization code,
+therefore it should be made signed explicitly, as on Linux 
+-funsigned-char option is specified when building OCCT */
+typedef  signed char  Tchar;
+typedef  char         Tbool;
+typedef  unsigned int Tuint;
 
 #define  TGL_SP   1
 #define  TGL_DP   0
@@ -37,6 +42,7 @@
 #define  TNotDone  0
 
 typedef  Tfloat  Tmatrix3[4][4];
+
 typedef  enum    
 { 
   TPreConcatenate, 
diff -Naur OpenCASCADE6.3.0/ros/inc/WNT_Window.hxx OpenCASCADE6.3.0sp6/ros/inc/WNT_Window.hxx
--- OpenCASCADE6.3.0/ros/inc/WNT_Window.hxx	2008-09-09 18:08:22.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/inc/WNT_Window.hxx	2009-10-03 01:03:31.000000000 +0200
@@ -104,6 +104,12 @@
 //!  Warning: The position and size for the creation of the window <br>
 //!	    are defined in Device Screen Unit (DSU) <br>
 //!	    floating [0,1] space. <br>
+//! <br>
+//!          As 3D view window is the main purpose of this class, <br>
+//!          and 3D view does not need its background to be drawn <br>
+//!          by the system, by default the window background is not drawn. <br>
+//!          This can be overridden by calling ClearFlags( WDF_NOERASEBKGRND ). <br>
+//!          See also WNT_WndProc.cxx and InterfaceGraphic_WNT.hxx. <br>
 class WNT_Window : public Aspect_Window {
 
 public:
@@ -256,9 +262,13 @@
 Standard_EXPORT   void SetPos(const Standard_Integer X,const Standard_Integer Y,const Standard_Integer X1,const Standard_Integer Y1) ;
 
 //! Sets user defined flags in the extra window data area. <br>
+//!          Supported flags WDF_* are listed in InterfaceGraphic_WNT.hxx <br>
+//!          In particular, the window backround can be turned off using this method. <br>
 Standard_EXPORT   void SetFlags(const Standard_Integer aFlags) ;
 
 //! Reset specified flags in the extra window data area. <br>
+//!          Supported flags WDF_* are listed in InterfaceGraphic_WNT.hxx <br>
+//!          In particular, the window backround can be turned on using this method. <br>
 Standard_EXPORT   void ResetFlags(const Standard_Integer aFlags) ;
 
 //! Returns the BackingStore capability for this Window. <br>
diff -Naur OpenCASCADE6.3.0/ros/src/Aspect/Aspect_GraphicCallbackProc.hxx OpenCASCADE6.3.0sp6/ros/src/Aspect/Aspect_GraphicCallbackProc.hxx
--- OpenCASCADE6.3.0/ros/src/Aspect/Aspect_GraphicCallbackProc.hxx	2003-05-30 18:55:57.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/Aspect/Aspect_GraphicCallbackProc.hxx	2009-10-03 01:03:55.000000000 +0200
@@ -15,6 +15,13 @@
 #define OCC_REDRAW_WINDOWAREA 2
 #define OCC_REDRAW_BITMAP 3
 
+/* 
+   This flag, when bitwise OR`ed with the "reason" value, 
+   informs the callback that it is called before redrawing the overlayer .
+   Otherwise, the callback is invoked after the overlayer is redrawn.        
+*/
+#define OCC_PRE_OVERLAY 0x8000
+
  typedef struct {
    int reason;
    int wsID;
diff -Naur OpenCASCADE6.3.0/ros/src/BOPTools/BOPTools_Tools.cxx OpenCASCADE6.3.0sp6/ros/src/BOPTools/BOPTools_Tools.cxx
--- OpenCASCADE6.3.0/ros/src/BOPTools/BOPTools_Tools.cxx	2004-08-06 19:11:25.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/BOPTools/BOPTools_Tools.cxx	2009-10-03 01:03:55.000000000 +0200
@@ -464,16 +464,27 @@
   //
   aNewSR=aSR;
   //
+  //modified by NIZNHY-PKV Tue Feb 10 08:47:03 2009f
+  aBC.Initialize(aE1);
+  aCT=aBC.GetType();
+  if (aCT==GeomAbs_Line) {
+    return;
+  }
+  //modified by NIZNHY-PKV Tue Feb 10 08:47:06 2009t
+  //
   dT=Precision::PConfusion();
   aTF=aSR.First();
   aTL=aSR.Last();
   //
+  //modified by NIZNHY-PKV Tue Feb 10 08:47:39 2009f
+  /*
   aBC.Initialize(aE1);
   aCT=aBC.GetType();
+  */
+  //modified by NIZNHY-PKV Tue Feb 10 08:47:43 2009t
   //
   aTolE1=BRep_Tool::Tolerance(aE1);
   aTolE2=BRep_Tool::Tolerance(aE2);
-  
   //
   for(i=0; i<2; ++i) {
     aRes = 2.*(aTolE1 + aTolE2);
diff -Naur OpenCASCADE6.3.0/ros/src/BOPTools/BOPTools_Tools3D_1.cxx OpenCASCADE6.3.0sp6/ros/src/BOPTools/BOPTools_Tools3D_1.cxx
--- OpenCASCADE6.3.0/ros/src/BOPTools/BOPTools_Tools3D_1.cxx	2008-05-08 15:08:45.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/BOPTools/BOPTools_Tools3D_1.cxx	2009-10-03 01:03:55.000000000 +0200
@@ -106,7 +106,6 @@
   //
   aETol = BRep_Tool::Tolerance(aE);
   aFTol = BRep_Tool::Tolerance(aF);
-  //modified by NIZNHY-PKV Fri Mar 28 15:09:30 2008f
   // pkv NPAL19220
   GeomAdaptor_Surface aGAS(aS);
   aTS=aGAS.GetType();
@@ -115,12 +114,10 @@
       aFTol=aETol;
     }
   }
-  //modified by NIZNHY-PKV Fri Mar 28 15:09:43 2008t
-  if( aETol > 1.e-5 && aFTol > 1.e-5 ) {
-    //modified by NIZNHY-PKV Fri Mar 28 15:09:52 2008f
-    //GeomAdaptor_Surface aGAS(aS);
-    //aTS=aGAS.GetType();
-    //modified by NIZNHY-PKV Fri Mar 28 15:10:01 2008t
+  //modified by NIZNHY-PKV Thu Mar 19 14:15:15 2009f
+  if( aETol > 1.e-5 || aFTol > 1.e-5 ) {
+  //if( aETol > 1.e-5 && aFTol > 1.e-5 ) {
+    //modified by NIZNHY-PKV Thu Mar 19 14:15:24 2009t
     //pkv/103/D7
     if(aTS!=GeomAbs_Sphere) {
       gp_Vec2d transVec( aDP );
diff -Naur OpenCASCADE6.3.0/ros/src/BRep/BRep_Tool.cxx OpenCASCADE6.3.0sp6/ros/src/BRep/BRep_Tool.cxx
--- OpenCASCADE6.3.0/ros/src/BRep/BRep_Tool.cxx	2008-06-27 17:50:44.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/BRep/BRep_Tool.cxx	2009-10-03 01:03:55.000000000 +0200
@@ -28,6 +28,7 @@
 #include <ElSLib.hxx>
 #include <Geom_Plane.hxx>
 #include <Geom_RectangularTrimmedSurface.hxx>
+#include <Geom_OffsetSurface.hxx>
 #include <Geom_TrimmedCurve.hxx>
 #include <Geom2d_TrimmedCurve.hxx>
 #include <ProjLib_ProjectedCurve.hxx>
@@ -41,6 +42,11 @@
 #include <Poly_Polygon2D.hxx>
 #include <Poly_PolygonOnTriangulation.hxx>
 
+//modified by NIZNHY-PKV Fri Oct 17 14:13:29 2008f
+static 
+  Standard_Boolean IsPlane(const Handle(Geom_Surface)& aS);
+//modified by NIZNHY-PKV Fri Oct 17 14:13:33 2008t
+//
 //=======================================================================
 //function : Surface
 //purpose  : Returns the geometric surface of the face. Returns
@@ -698,6 +704,12 @@
 				     const Handle(Geom_Surface)& S,
 				     const TopLoc_Location& L)
 {
+  //modified by NIZNHY-PKV Fri Oct 17 12:16:58 2008f
+  if (IsPlane(S)) {
+    return Standard_False;
+  }
+  //modified by NIZNHY-PKV Fri Oct 17 12:16:54 2008t
+  //
   TopLoc_Location      l = L.Predivided(E.Location());
 
   // find the representation
@@ -1496,13 +1508,11 @@
   Standard_NoSuchObject::Raise("BRep_Tool:: no parameters on surface");
   return gp_Pnt2d(0,0);
 }
-
 //=======================================================================
 //function : IsClosed
 //purpose  : Returns <True>  if S if flaged Closed, if S is a
 //           Solid,Shell or Compound  returns <True> is S has no free boundaries.
 //=======================================================================
-
 Standard_Boolean BRep_Tool::IsClosed(const TopoDS_Shape& S)
 {
   if (S.ShapeType() == TopAbs_SHELL || S.ShapeType() == TopAbs_SOLID ||
@@ -1519,3 +1529,33 @@
   }
   return (S.Closed());
 }
+
+//modified by NIZNHY-PKV Fri Oct 17 14:09:58 2008 f 
+//=======================================================================
+//function : IsPlane
+//purpose  : 
+//=======================================================================
+Standard_Boolean IsPlane(const Handle(Geom_Surface)& aS)
+{
+  Standard_Boolean bRet;
+  Handle(Geom_Plane) aGP;
+  Handle(Geom_RectangularTrimmedSurface) aGRTS;
+  Handle(Geom_OffsetSurface) aGOFS;
+  //
+  aGRTS=Handle(Geom_RectangularTrimmedSurface)::DownCast(aS);
+  aGOFS=Handle(Geom_OffsetSurface)::DownCast(aS);
+  //
+  if(!aGOFS.IsNull()) {
+    aGP=Handle(Geom_Plane)::DownCast(aGOFS->BasisSurface());
+  }
+  else if(!aGRTS.IsNull()) {
+    aGP=Handle(Geom_Plane)::DownCast(aGRTS->BasisSurface());
+  }
+  else {
+    aGP=Handle(Geom_Plane)::DownCast(aS);
+  }
+  //
+  bRet=!aGP.IsNull();
+  //
+  return bRet;
+}
diff -Naur OpenCASCADE6.3.0/ros/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx OpenCASCADE6.3.0sp6/ros/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx
--- OpenCASCADE6.3.0/ros/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx	2006-08-11 19:00:41.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx	2009-10-03 08:33:16.000000000 +0200
@@ -4331,11 +4331,17 @@
     Standard_Real first2d=0., last2d=0.,first2d1=0,last2d1=0.;
     Handle(Geom2d_Curve) c2d = BRep_Tool::CurveOnSurface(sec, fac, first2d, last2d);
     if (c2d.IsNull()) continue;
-
+    Handle(Geom2d_Curve) c2d1;
     Standard_Boolean isSeam = BRep_Tool::IsClosed(sec,fac);
+   
+    //gka  - Convert to BSpline was commented because
+    //it is not necessary to create BSpline instead of Lines or cIrcles.
+    //Besides after conversion circles to BSpline
+    //it is necessary to recompute parameters of cutting because paramerization of created
+    //BSpline curve differs from parametrization of circle.
 
     // Convert pcurve to BSpline
-    Handle(Geom2d_BSplineCurve) c2dBSP,c2dBSP1;
+    /*Handle(Geom2d_BSplineCurve) c2dBSP,c2dBSP1;
     if (c2d->IsKind(STANDARD_TYPE(Geom2d_BSplineCurve))) {
       c2dBSP = Handle(Geom2d_BSplineCurve)::DownCast(c2d);
     }
@@ -4347,34 +4353,37 @@
       }
       else c2dBSP = Geom2dConvert::CurveToBSplineCurve(c2d);
     }
-    if (c2dBSP.IsNull()) continue;
+    if (c2dBSP.IsNull()) continue;*/
     //gka fix for bug OCC12203 21.04.06 addition second curve for seam edges
+    
     if(isSeam)
     {
       TopoDS_Edge secRev = TopoDS::Edge(sec.Reversed());
       
-      Handle(Geom2d_Curve) c2d1 = BRep_Tool::CurveOnSurface(secRev, fac, first2d1, last2d1);
+      c2d1 = BRep_Tool::CurveOnSurface(secRev, fac, first2d1, last2d1);
       if (c2d1.IsNull()) continue;
-      if (c2d1->IsKind(STANDARD_TYPE(Geom2d_BSplineCurve))) {
+    
+      /*if (c2d1->IsKind(STANDARD_TYPE(Geom2d_BSplineCurve))) {
         c2dBSP1 = Handle(Geom2d_BSplineCurve)::DownCast(c2d1);
       }
       else {
         if (first > (c2d1->FirstParameter() + Precision::PConfusion()) ||
             last < (c2d1->LastParameter() - Precision::PConfusion())) {
           Handle(Geom2d_TrimmedCurve) TC = new Geom2d_TrimmedCurve(c2d1, first, last);
-          c2dBSP1 = Geom2dConvert::CurveToBSplineCurve(TC);
+          //c2dBSP1 = Geom2dConvert::CurveToBSplineCurve(TC);
         }
-        else c2dBSP1 = Geom2dConvert::CurveToBSplineCurve(c2d);
+        //else c2dBSP1 = Geom2dConvert::CurveToBSplineCurve(c2d);
       
-      }
+      }*/
     }
 
-    first2d = c2dBSP->FirstParameter();
+    /*first2d = c2dBSP->FirstParameter();
     last2d = c2dBSP->LastParameter();
+       
     if(!c2dBSP1.IsNull()) {
       first2d1 = c2dBSP1->FirstParameter();
       last2d1 = c2dBSP1->LastParameter();
-    }
+    }*/
       
     // Update cutting sections
     Handle(Geom2d_Curve) c2dNew,c2d1New;
@@ -4386,23 +4395,24 @@
       BRep_Tool::Range(edge, par1, par2);
 
       // Cut BSpline pcurve
-      try {
-        
-	c2dNew = Handle(Geom2d_Curve)::DownCast(c2dBSP->Copy());
-	Handle(Geom2d_BSplineCurve)::DownCast(c2dNew)->Segment(Max(first2d,par1),Min(par2,last2d));
-        if(!c2dBSP1.IsNull()) {
-          c2d1New = Handle(Geom2d_Curve)::DownCast(c2dBSP1->Copy());
-          Handle(Geom2d_BSplineCurve)::DownCast(c2d1New)->Segment(Max(first2d1,par1),Min(par2,last2d1));
+     // try {
+        c2dNew = Handle(Geom2d_Curve)::DownCast(c2d->Copy());
+        //c2dNew = Handle(Geom2d_Curve)::DownCast(c2dBSP->Copy());
+	//Handle(Geom2d_BSplineCurve)::DownCast(c2dNew)->Segment(Max(first2d,par1),Min(par2,last2d));
+        if(!c2d1.IsNull()) { //if(!c2dBSP1.IsNull()) {
+          c2d1New = Handle(Geom2d_Curve)::DownCast(c2d1->Copy()); 
+          //c2d1New = Handle(Geom2d_Curve)::DownCast(c2dBSP1->Copy());
+          //Handle(Geom2d_BSplineCurve)::DownCast(c2d1New)->Segment(Max(first2d1,par1),Min(par2,last2d1));
         }
-      }
-      catch (Standard_Failure) {
+      //}
+      /*catch (Standard_Failure) {
 #ifdef DEB
 	cout << "Exception in CreateSections: segment [" << par1 << "," << par2 << "]: ";
 	Standard_Failure::Caught()->Print(cout); cout << endl;
 #endif
 	Handle(Geom2d_TrimmedCurve) c2dT = new Geom2d_TrimmedCurve(c2dNew,Max(first2d,par1),Min(par2,last2d));
 	c2dNew = c2dT;
-      }
+      }*/
               
 
       if(!isSeam && c2d1New.IsNull())
diff -Naur OpenCASCADE6.3.0/ros/src/BRepFill/BRepFill_CompatibleWires.cxx OpenCASCADE6.3.0sp6/ros/src/BRepFill/BRepFill_CompatibleWires.cxx
--- OpenCASCADE6.3.0/ros/src/BRepFill/BRepFill_CompatibleWires.cxx	2006-12-08 17:05:41.000000000 +0100
+++ OpenCASCADE6.3.0sp6/ros/src/BRepFill/BRepFill_CompatibleWires.cxx	2009-10-03 01:03:56.000000000 +0200
@@ -562,7 +562,38 @@
   }
 }
 
+static void BuildConnectedEdges(const TopoDS_Wire& aWire,
+				const TopoDS_Edge& StartEdge,
+				const TopoDS_Vertex& StartVertex,
+				TopTools_ListOfShape& ConnectedEdges)
+{
+  TopTools_IndexedDataMapOfShapeListOfShape MapVE;
+  TopExp::MapShapesAndAncestors(aWire, TopAbs_VERTEX, TopAbs_EDGE, MapVE);
+  TopoDS_Edge CurEdge = StartEdge;
+  TopoDS_Vertex CurVertex = StartVertex;
+  TopoDS_Vertex Origin, V1, V2;
+  TopExp::Vertices(StartEdge, V1, V2);
+  Origin = (V1.IsSame(StartVertex))? V2 : V1;
 
+  for (;;)
+    {
+      TopTools_ListIteratorOfListOfShape itE( MapVE.FindFromKey(CurVertex) );
+      for (; itE.More(); itE.Next())
+	{
+	  TopoDS_Edge anEdge = TopoDS::Edge(itE.Value());
+	  if (!anEdge.IsSame(CurEdge))
+	    {
+	      ConnectedEdges.Append(anEdge);
+	      TopExp::Vertices(anEdge, V1, V2);
+	      CurVertex = (V1.IsSame(CurVertex))? V2 : V1;
+	      CurEdge = anEdge;
+	      break;
+	    }
+	}
+      if (CurVertex.IsSame(Origin))
+	break;
+    }
+}
 				      
 //=======================================================================
 //function : BRepFill_CompatibleWires
@@ -994,34 +1025,32 @@
 
     BRepLib_MakeWire MW;
 
-    for(anExp.Init(wire); anExp.More(); anExp.Next()) {
-      
-      TopoDS_Edge ECur = anExp.Current();
-      TopoDS_Vertex VF,VL;
-      TopExp::Vertices(ECur,VF,VL,Standard_True);
-      Standard_Real U1 = BRep_Tool::Parameter(VF,ECur);
-      Standard_Real U2 = BRep_Tool::Parameter(VL,ECur);
-      BRepAdaptor_Curve Curve(ECur);
-      gp_Pnt PPs = Curve.Value(0.1*(U1+9*U2));
-      TopTools_ListIteratorOfListOfShape itF(MapVLV(VF)),itL(MapVLV(VL));
-      Standard_Integer rang = ideb;
-      while (rang < i) {
-	itF.Next();
-	itL.Next();
-	rang++;
-      }
-      TopoDS_Vertex V1 = TopoDS::Vertex(itF.Value()), 
-                    V2 = TopoDS::Vertex(itL.Value());
-      TopoDS_Edge Esol;
-      Standard_Real scalmax=0.;
-      BRepTools_WireExplorer anExp2;
-  
-      for(anExp2.Init(TopoDS::Wire(myWork(i))); anExp2.More(); anExp2.Next()) {
-
-	TopoDS_Edge E = TopoDS::Edge(anExp2.Current());
+    anExp.Init(wire);
+    TopoDS_Edge ECur = anExp.Current();
+    TopoDS_Vertex VF,VL;
+    TopExp::Vertices(ECur,VF,VL,Standard_True);
+    Standard_Real U1 = BRep_Tool::Parameter(VF,ECur);
+    Standard_Real U2 = BRep_Tool::Parameter(VL,ECur);
+    BRepAdaptor_Curve Curve(ECur);
+    gp_Pnt PPs = Curve.Value(0.1*(U1+9*U2));
+    TopTools_ListIteratorOfListOfShape itF(MapVLV(VF)),itL(MapVLV(VL));
+    Standard_Integer rang = ideb;
+    while (rang < i) {
+      itF.Next();
+      itL.Next();
+      rang++;
+    }
+    TopoDS_Vertex V1 = TopoDS::Vertex(itF.Value()), V2 = TopoDS::Vertex(itL.Value());
+    TopoDS_Edge Esol;
+    Standard_Real scalmax=0.;
+    TopoDS_Iterator itW( myWork(i) );
+    
+    for(; itW.More(); itW.Next())
+      {
+	TopoDS_Edge E = TopoDS::Edge(itW.Value());
 	TopoDS_Vertex VVF,VVL;
 	TopExp::Vertices(E,VVF,VVL,Standard_True);
-
+	
 	// tri des edges candidates
 	Standard_Real scal1,scal2;
 	if ( (V1.IsSame(VVF)&&V2.IsSame(VVL)) || (V2.IsSame(VVF)&&V1.IsSame(VVL)) ) {
@@ -1055,17 +1084,59 @@
 	    scalmax = scal2;
 	    TopoDS_Shape aLocalShape = E.Reversed();
 	    Esol = TopoDS::Edge(aLocalShape);
-//	    Esol = TopoDS::Edge(E.Reversed());
 	  }
-
 	}
+	if (!Esol.IsNull())
+	  break;
       }
-      MW.Add(Esol);
+    MW.Add(Esol);
+
+    TopTools_ListOfShape ConnectedEdges;
+    BuildConnectedEdges( TopoDS::Wire(myWork(i)), Esol, V2, ConnectedEdges );
+
+    TopTools_ListIteratorOfListOfShape itCE(ConnectedEdges);
+    for(; anExp.More(), itCE.More(); anExp.Next(), itCE.Next())
+      {
+	ECur = anExp.Current();
+	TopExp::Vertices(ECur,VF,VL,Standard_True);
+	U1 = BRep_Tool::Parameter(VF,ECur);
+	U2 = BRep_Tool::Parameter(VL,ECur);
+	Curve.Initialize(ECur);
+	PPs = Curve.Value(0.1*(U1+9*U2));
 	
-    }
+	TopoDS_Edge E = TopoDS::Edge(itCE.Value());
+	TopoDS_Vertex VVF,VVL;
+	TopExp::Vertices(E,VVF,VVL,Standard_True);
 
+	// tri des edges candidates
+	Standard_Real scal1,scal2;
+	U1 = BRep_Tool::Parameter(VVF,E);
+	U2 = BRep_Tool::Parameter(VVL,E);
+	Curve.Initialize(E);
+	gp_Pnt PP1 = Curve.Value(0.1*(U1+9*U2));
+	gp_Pnt PP2 = Curve.Value(0.1*(9*U1+U2));
+	
+	for (rang=i;rang>ideb;rang--) {
+	  Transform(WithRotation, PP1,
+		    Pos->Value(rang), Axe->Value(rang),
+		    Pos->Value(rang-1), Axe->Value(rang-1), PP1);
+	  Transform(WithRotation, PP2,
+		    Pos->Value(rang), Axe->Value(rang),
+		    Pos->Value(rang-1), Axe->Value(rang-1), PP2);
+	}
+	gp_Vec Ns(Pos->Value(ideb),PPs);
+	Ns = Ns.Normalized();
+	gp_Vec N1(Pos->Value(ideb),PP1);
+	N1 = N1.Normalized();
+	gp_Vec N2(Pos->Value(ideb),PP2);
+	N2 = N2.Normalized();
+	scal1 = N1.Dot(Ns);
+	scal2 = N2.Dot(Ns);
+	if (scal2>scal1)
+	  E.Reverse();
+	MW.Add(E);
+      }
     myWork(i) = MW.Wire();
-
   }
   
   // sections bouclantes ?
diff -Naur OpenCASCADE6.3.0/ros/src/BRepFill/BRepFill_Sweep.cdl OpenCASCADE6.3.0sp6/ros/src/BRepFill/BRepFill_Sweep.cdl
--- OpenCASCADE6.3.0/ros/src/BRepFill/BRepFill_Sweep.cdl	2003-05-30 18:54:10.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/BRepFill/BRepFill_Sweep.cdl	2009-10-03 01:03:56.000000000 +0200
@@ -69,7 +69,7 @@
          Transition : TransitionStyle  =  BRepFill_Modified;    
          Approx     : ApproxStyle = GeomFill_Location; 
          Continuity : Shape  from  GeomAbs   = GeomAbs_C2;
-	 Degmax     : Integer = 10;
+	 Degmax     : Integer = 11;
          Segmax     : Integer = 30); 
 	 
    ---Purpose: Build the Sweeep  Surface
@@ -87,19 +87,16 @@
    --    Segmax     : The maximum number of span in v requiered on 
    --                 the surface.
     
+   CorrectApproxParameters(me:  in  out)
+   returns  Boolean  is  private; 
+   
    BuildWire(me : in  out; 
-         Transition : TransitionStyle;     
-         Approx     : ApproxStyle; 
-         Continuity : Shape  from  GeomAbs;
-	 Degmax,  Segmax  : Integer)   
+             Transition : TransitionStyle)
    returns  Boolean  is  private; 
 	  
    BuildShell(me : in  out;   
             Transition : TransitionStyle;              
             Vf,  Vl    : Integer;    
-            Approx     : ApproxStyle; 
-            Continuity : Shape  from  GeomAbs;
-	    Degmax,  Segmax  : Integer; 
             ExtendFirst :  Real  =  0.0; 
             ExtendLast  :  Real  =  0.0)  
    returns Boolean is  private;
@@ -153,7 +150,11 @@
   myTol2d          :  Real;   
   myTolAngular     :  Real; 
   myAngMin         :  Real; 
-  myAngMax         :  Real;
+  myAngMax         :  Real; 
+  myApproxStyle    :  ApproxStyle from GeomFill; 
+  myContinuity     :  Shape from  GeomAbs; 
+  myDegmax         :  Integer; 
+  mySegmax         :  Integer;
   myShape          :  Shape from  TopoDS; 
   myLoc            :  LocationLaw  from  BRepFill; 
   mySec            :  SectionLaw   from  BRepFill; 
diff -Naur OpenCASCADE6.3.0/ros/src/BRepFill/BRepFill_Sweep.cxx OpenCASCADE6.3.0sp6/ros/src/BRepFill/BRepFill_Sweep.cxx
--- OpenCASCADE6.3.0/ros/src/BRepFill/BRepFill_Sweep.cxx	2007-02-09 18:14:09.000000000 +0100
+++ OpenCASCADE6.3.0sp6/ros/src/BRepFill/BRepFill_Sweep.cxx	2009-10-03 01:03:56.000000000 +0200
@@ -1667,6 +1667,11 @@
  SetTolerance(1.e-4);
  SetAngularControl();
  myAuxShape.Clear();
+
+ myApproxStyle = GeomFill_Location;
+ myContinuity  = GeomAbs_C2;
+ myDegmax      = 11;
+ mySegmax      = 30;
 }
 
 //=======================================================================
@@ -1734,16 +1739,43 @@
   myAngMax = Min (MaxAngle, 6.28);
 }
 
+///=======================================================================
+//function : CorrectApproxParameters
+//purpose  : 
+//=======================================================================
+ Standard_Boolean BRepFill_Sweep::CorrectApproxParameters()
+{
+  TopoDS_Wire thePath = myLoc->Wire();
+  GeomAbs_Shape    NewCont   = myContinuity;
+  Standard_Integer NewSegmax = mySegmax;
+
+  TopoDS_Iterator iter(thePath);
+  for (; iter.More(); iter.Next())
+    {
+      TopoDS_Edge anEdge = TopoDS::Edge(iter.Value());
+      BRepAdaptor_Curve aBAcurve(anEdge);
+      GeomAbs_Shape aContinuity = aBAcurve.Continuity();
+      Standard_Integer aNbInterv = aBAcurve.NbIntervals(GeomAbs_CN);
+      if (aContinuity < NewCont)
+	NewCont = aContinuity;
+      if (aNbInterv > NewSegmax)
+	NewSegmax = aNbInterv;
+    }
+
+  Standard_Boolean Corrected = Standard_False;
+  if (NewCont != myContinuity || NewSegmax != mySegmax)
+    Corrected = Standard_True;
+  myContinuity = NewCont;
+  mySegmax     = NewSegmax;
+  return Corrected;
+}
+
 //=======================================================================
 //function : BuildWire
 //purpose  : Construit un wire par balayage
 //======================================================================
- Standard_Boolean 
- BRepFill_Sweep::BuildWire(const BRepFill_TransitionStyle Transition,
-			   const GeomFill_ApproxStyle Approx,
-			   const GeomAbs_Shape Continuity,
-			   const Standard_Integer Degmax,
-			   const Standard_Integer Segmax) 
+ Standard_Boolean BRepFill_Sweep::
+ BuildWire(const BRepFill_TransitionStyle Transition)
 {
   Standard_Integer ipath, isec = 1;
   gp_Pnt P1;//, P2;
@@ -1775,7 +1807,7 @@
     // Courbe par iso valeur
     GeomFill_Sweep Sweep(myLoc->Law(ipath), KPart);
     Sweep.SetTolerance(myTol3d, myBoundTol, myTol2d, myTolAngular);
-    Sweep.Build(mySec->Law(isec), Approx, Continuity, Degmax, Segmax);
+    Sweep.Build(mySec->Law(isec), myApproxStyle, myContinuity, myDegmax, mySegmax);
     if (!Sweep.IsDone())  
       return Standard_False;
     S = Sweep.Surface();
@@ -1871,10 +1903,6 @@
  BuildShell(const BRepFill_TransitionStyle Transition,
 	    const Standard_Integer IFirst,
 	    const Standard_Integer ILast,
-	    const GeomFill_ApproxStyle Approx,
-	    const GeomAbs_Shape Continuity,
-	    const Standard_Integer Degmax,
-	    const Standard_Integer Segmax,
 	    const Standard_Real ExtendFirst,
 	    const Standard_Real ExtendLast) 
 {
@@ -1955,7 +1983,7 @@
     }
     
     for(isec=1; isec<=NbLaw; isec++) {
-      Sweep.Build(mySec->Law(isec), Approx, Continuity, Degmax, Segmax);
+      Sweep.Build(mySec->Law(isec), myApproxStyle, myContinuity, myDegmax, mySegmax);
       if (!Sweep.IsDone()) 
 	return Standard_False;
       TabS(isec,ipath) = Sweep.Surface();
@@ -2448,9 +2476,16 @@
 			    const Standard_Integer Degmax,
 			    const Standard_Integer Segmax) 
 {
+  myApproxStyle = Approx;
+  myContinuity  = Continuity;
+  myDegmax = Degmax;
+  mySegmax = Segmax;
+
+  CorrectApproxParameters();
+
   // Wire
-  if (mySec->IsVertex()) isDone = BuildWire(Transition, Approx, Continuity, 
-					    Degmax, Segmax);   
+  if (mySec->IsVertex()) isDone = BuildWire(Transition);
+
   else { // Shell   
     Standard_Integer NbTrous = myLoc->NbHoles(myTol3d),
                      NbPath   = myLoc->NbLaw(),
@@ -2476,8 +2511,7 @@
       if (NbTrous==1)  Extend = EvalExtrapol(1, Transition);
       isDone = BuildShell(Transition, 
 			  1, NbPath+1,
-			  Approx, Continuity, 
-			  Degmax, Segmax, Extend, Extend);
+			  Extend, Extend);
     }
     else { //  On le fait bout par bout
       Standard_Integer IFirst = 1, ILast;
@@ -2487,8 +2521,6 @@
 	else ILast = Trous->Value(ii);
 	isDone = BuildShell(Transition, 
 			    IFirst, ILast,
-			    Approx, Continuity, 
-			    Degmax, Segmax,
 			    EvalExtrapol(IFirst, Transition),
 			    EvalExtrapol(ILast,  Transition));
 	if (IFirst>1) {
diff -Naur OpenCASCADE6.3.0/ros/src/BRepMesh/BRepMesh_FastDiscret.cdl OpenCASCADE6.3.0sp6/ros/src/BRepMesh/BRepMesh_FastDiscret.cdl
--- OpenCASCADE6.3.0/ros/src/BRepMesh/BRepMesh_FastDiscret.cdl	2008-07-25 16:03:13.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/BRepMesh/BRepMesh_FastDiscret.cdl	2009-10-03 01:03:56.000000000 +0200
@@ -145,16 +145,6 @@
     	returns Boolean;
 	
 
-    	InternalVerticesForRectangle
-    	       (me         : mutable;
-	       	caro       : HSurface            from BRepAdaptor;
-    	    	inter      : in out ListOfVertex from BRepMesh;
-    	        u1pars     : ListOfReal  from  TColStd;
-    	        u2pars     : ListOfReal  from  TColStd;
-    	        v1pars     : ListOfReal  from  TColStd;
-    	        v2pars     : ListOfReal  from  TColStd)
-	is static private;
- 
     	InternalVertices
     	       (me         : mutable;
 	       	caro       : HSurface            from BRepAdaptor;
diff -Naur OpenCASCADE6.3.0/ros/src/BRepMesh/BRepMesh_FastDiscret.cxx OpenCASCADE6.3.0sp6/ros/src/BRepMesh/BRepMesh_FastDiscret.cxx
--- OpenCASCADE6.3.0/ros/src/BRepMesh/BRepMesh_FastDiscret.cxx	2008-08-15 15:54:05.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/BRepMesh/BRepMesh_FastDiscret.cxx	2009-10-03 01:03:56.000000000 +0200
@@ -280,6 +280,7 @@
   TopTools_SequenceOfShape aShSeq;
 
   TopoDS_Iterator exW(face);
+
   for (; exW.More(); exW.Next()) {
     const TopoDS_Shape& aWire = exW.Value();
     if (aWire.ShapeType() != TopAbs_WIRE)
@@ -623,39 +624,14 @@
     myUParam.Clear(); myVParam.Clear();
   
     BRepMesh_IDMapOfNodeOfDataStructureOfDelaun aMoveNodes(myvemap.Extent());
-    //cout << "UVparam" << endl;
-    Standard_Real eps = Precision::PConfusion();
-    Standard_Integer nbu1 = 0, nbu2 = 0, nbv1 = 0, nbv2 = 0, nbtot = 0;
-    Standard_Boolean IsRectangle = Standard_False;
-    TColStd_ListOfReal U1Params, U2Params, V1Params, V2Params;
 
     for (i = 1; i <= structure->NbNodes(); i++)
     {
       const BRepMesh_Vertex& v = structure->GetNode(i);
       p2d = v.Coord();
       if (useUVParam) {
-	//cout << p2d.X() << " " << p2d.Y() << endl;
-	Standard_Real u = p2d.X(), v = p2d.Y();
-        myUParam.Add(u);
-        myVParam.Add(v);
-
-	++nbtot;
-	if(Abs(u - myumin) <= eps) {
-	  ++nbu1;
-	  V1Params.Append(v);
-	}
-	if(Abs(u - myumax) <= eps) {
-	  ++nbu2;
-	  V2Params.Append(v);
-	}
-	if(Abs(v - myvmin) <= eps) {
-	  ++nbv1;
-	  U1Params.Append(u);
-	}
-	if(Abs(v - myvmax) <= eps) {
-	  ++nbv2;
-	  U2Params.Append(u);
-	}
+        myUParam.Add(p2d.X());
+        myVParam.Add(p2d.Y());
       }
       gp_XY res;
       res.SetCoord((p2d.X()-minX)/deltaX,(p2d.Y()-minY)/deltaY);
@@ -666,12 +642,6 @@
     }    
     structure->ReplaceNodes(aMoveNodes);
     
-    if(useUVParam) {
-      Standard_Integer nb = nbu1 + nbu2 + nbv1 + nbv2 - 4;
-      if((nbu1 == nbu2) && (nbv1 == nbv2) && (nbtot == nb)) IsRectangle = Standard_True;
-    }
-
-
     Standard_Boolean rajout;
 
      switch (thetype)
@@ -719,14 +689,9 @@
       }
 
       if(rajout){
-	if(IsRectangle) {
-	  InternalVerticesForRectangle(gFace, mylistver, U1Params, U2Params, V1Params, V2Params);
-	}
-	else {
-	  InternalVertices(gFace, mylistver, defface,*classifier);
-	}
+        InternalVertices(gFace, mylistver, defface,*classifier);
 
-        if (mylistver.Extent() > 0) {
+      if (mylistver.Extent() > 0) {
 	  BRepMesh_Array1OfVertexOfDelaun verttab(1, mylistver.Extent());
 	  BRepMesh_ListIteratorOfListOfVertex itVer(mylistver);
 	  ipn = 1;
@@ -1909,78 +1874,73 @@
 
     // Sort sequence of U parameters
     TColStd_SequenceOfReal ParamU;
-    ParamU.Append(myumin); ParamU.Append(myumax);
-    Standard_Integer ParamULength = 2;
+    Standard_Integer ParamULength = 1;
     const Standard_Integer LenU = myUParam.Extent();
-    const Standard_Real ddu = 0.02*(myumax-myumin);
+
+    Standard_Real ddu = caro->UResolution(defface);
     
     Standard_Real U1, U2;
 
+    TColStd_Array1OfReal uprs(1, LenU);
     for (j = 1; j <= LenU; j++)
     {
-      pp = myUParam(j);
+      uprs(j) = myUParam(j);
+    }
+    SortTools_ShellSortOfReal aSorter;
+    TCollection_CompareOfReal aCompare;
+    aSorter.Sort(uprs, aCompare);
 
-      U1 = ParamU.Value(1);
-      for (i = 2; i <= ParamULength; i++)
+    U1 = uprs(1);
+    ParamU.Append(U1);
+    for (j = 2; j <= LenU; j++)
+    {
+      U2 = uprs(j);
+      if ((U2-U1) > ddu)
       {
-	U2 = ParamU.Value(i);
-	if (pp < U2)
-        {
-	  if ((U2-pp) < ddu)
-          {
-	    ParamU(i) = pp;
-	  }
-	  else if ((pp-U1) > ddu)
-          {
-	    ParamU.InsertBefore(i, pp);
-	    ParamULength++;
-	  }
-	  else if (i != 2)
-          {
-	    ParamU(i-1) = pp;
-	  }
-	  break;
-	}
+        ParamU.Append(U2);
         U1 = U2;
+        ParamULength++;
       }
     }
-    
+    if(uprs(LenU)-ParamU(ParamULength)>Precision::Confusion())
+    {
+      ParamU.Append(uprs(LenU));        
+      ParamULength++;
+    }
+
     // Sort sequence of V parameters
     TColStd_SequenceOfReal ParamV;
-    ParamV.Append(myvmin); ParamV.Append(myvmax);
-    Standard_Integer ParamVLength = 2;
+    Standard_Integer ParamVLength = 1;
     const Standard_Integer LenV = myVParam.Extent();
-    const Standard_Real ddv = 0.02*(myvmax-myvmin);
+
+    Standard_Real ddv = caro->VResolution(defface);
 
     Standard_Real V1, V2;
+
+    TColStd_Array1OfReal vprs(1, LenV);
     for (j = 1; j <= LenV; j++)
     {
-      pp = myVParam(j);
+      vprs(j) = myVParam(j);
+    }
+    aSorter.Sort(vprs, aCompare);
 
-      V1 = ParamV.Value(1);
-      for (i = 2; i <= ParamVLength; i++)
+    V1 = vprs(1);
+    ParamV.Append(V1);
+    for (j = 2; j <= LenV; j++)
+    {
+      V2 = vprs(j);
+      if ((V2-V1) > ddv)
       {
-	V2 = ParamV.Value(i);
-	if (pp < V2)
-        {
-	  if ((V2-pp) < ddv)
-          {
-	    ParamV(i) = pp;
-	  }
-	  else if ((pp-V1) > ddv)
-          {
-	    ParamV.InsertBefore(i, pp);
-	    ParamVLength++;
-	  }
-	  else if (i != 2)
-          {
-	    ParamV(i-1) = pp;
-	  }
-	  break;
-	}
+        ParamV.Append(V2);
         V1 = V2;
+        ParamVLength++;
       }
     }
+    if(vprs(LenV)-ParamV(ParamVLength)>Precision::Confusion())
+    {
+      ParamV.Append(vprs(LenV));        
+      ParamVLength++;
+    }
 
     // controle des isos U et insertion eventuelle:
 
@@ -2192,84 +2152,6 @@
 }
 
 //=======================================================================
-//function : InternalVerticesForRectangle
-//purpose  : 
-//=======================================================================
-void BRepMesh_FastDiscret::
-  InternalVerticesForRectangle(const Handle(BRepAdaptor_HSurface)& caro,
-			       BRepMesh_ListOfVertex&              InternalV,
-			       const TColStd_ListOfReal&           U1Params,
-			       const TColStd_ListOfReal&           U2Params,
-			       const TColStd_ListOfReal&           V1Params,
-			       const TColStd_ListOfReal&           V2Params)
-{
-  BRepMesh_Vertex newV;
-  gp_XY p2d;
-  gp_Pnt p3d;
-
-
-  Standard_Integer i, j, nbu = U1Params.Extent(), 
-                         nbv = V1Params.Extent();
-  TColStd_Array1OfReal u1prs(1, nbu), u2prs(1, nbu), 
-                       v1prs(1, nbv), v2prs(1,nbv);
-  TColStd_ListIteratorOfListOfReal Itu1(U1Params), Itu2(U2Params), 
-                                   Itv1(V1Params), Itv2(V2Params);
-  for(i = 1; Itu1.More(); Itu1.Next(), Itu2.Next(),++i) {
-    u1prs(i) = Itu1.Value();
-    u2prs(i) = Itu2.Value();
-  }
-  for(i = 1; Itv1.More(); Itv1.Next(), Itv2.Next(),++i) {
-    v1prs(i) = Itv1.Value();
-    v2prs(i) = Itv2.Value();
-  }
-  
-  SortTools_ShellSortOfReal aSorter;
-  TCollection_CompareOfReal aCompare;
-  aSorter.Sort(u1prs, aCompare);
-  aSorter.Sort(u2prs, aCompare);
-  aSorter.Sort(v1prs, aCompare);
-  aSorter.Sort(v2prs, aCompare);
-
-  gp_XY f00(u1prs(1), v1prs(1));
-  gp_XY f01(u2prs(1), v1prs(nbv));
-  gp_XY f10(u1prs(nbu), v2prs(1));
-  gp_XY f11(u2prs(nbu), v2prs(nbv));
-
-  Standard_Real cu = 1./(nbu-1), cv = 1./(nbv-1);
-
-  //Linear Coons-Gordon interpolation for inner points
-  Standard_Real x, y, x1, y1;
-  for(i = 2, x = cu; i < nbu; ++i, x += cu) {
-    x1 = 1.-x;
-    gp_XY fx0(u1prs(i), v1prs(1));
-    gp_XY fx1(u2prs(i), v1prs(nbv));
- 
-    for(j = 2, y = cv; j < nbv; ++j, y += cv) {
-      y1 = 1.-y;
-
-      gp_XY f0y(u1prs(1), v1prs(j));
-      gp_XY f1y(u1prs(nbu), v2prs(j));
-		
-      gp_XY fxy = y1*fx0 + y*fx1 + x1*f0y + x*f1y -
-                  (x1*(y1*f00 + y*f01) + x*(y1*f10 + y*f11));
-
-      // Record 3d point
-      BRepMesh_GeomTool::D0(caro, fxy.X(), fxy.Y(), p3d);
-      nbLocat++;
-      Location3d.Bind(nbLocat, p3d);
-      // Record 2d point
-      p2d.SetCoord((fxy.X()-myumin)/deltaX, (fxy.Y()-myvmin)/deltaY);
-      newV.Initialize(p2d, nbDomains, nbLocat, MeshDS_Free);
-      InternalV.Append(newV);
-    }
-  }
-      
-
-
-}
-
-
-//=======================================================================
 //function : Control
 //purpose  : 
 //=======================================================================
diff -Naur OpenCASCADE6.3.0/ros/src/Extrema/Extrema_ExtPElC.cxx OpenCASCADE6.3.0sp6/ros/src/Extrema/Extrema_ExtPElC.cxx
--- OpenCASCADE6.3.0/ros/src/Extrema/Extrema_ExtPElC.cxx	2002-12-06 19:00:53.000000000 +0100
+++ OpenCASCADE6.3.0sp6/ros/src/Extrema/Extrema_ExtPElC.cxx	2009-10-03 01:04:01.000000000 +0200
@@ -107,15 +107,13 @@
   Usol[1] = Usol[0] + PI;
 
   Standard_Real myuinf = Uinf;
-  //modified by NIZNHY-PKV Fri Apr 20 15:03:28 2001 f
-  //Standard_Real TolU = Tol*C.Radius();
   Standard_Real TolU, aR;
   aR=C.Radius();
   TolU=Precision::Infinite();
   if (aR > gp::Resolution()) {
     TolU= Tol/aR;
   }
-  //modified by NIZNHY-PKV Fri Apr 20 15:03:32 2001 t
+  //
   ElCLib::AdjustPeriodic(Uinf, Uinf+2*PI, Precision::PConfusion(), myuinf, Usol[0]);
   ElCLib::AdjustPeriodic(Uinf, Uinf+2*PI, Precision::PConfusion(), myuinf, Usol[1]);
   if (((Usol[0]-2*PI-Uinf) < TolU) && ((Usol[0]-2*PI-Uinf) > -TolU)) Usol[0] = Uinf;
@@ -140,6 +138,10 @@
 }
 //=============================================================================
 
+//=======================================================================
+//function : Extrema_ExtPElC
+//purpose  : 
+//=======================================================================
 Extrema_ExtPElC::Extrema_ExtPElC (const gp_Pnt&       P,
 				  const gp_Elips&     C,
 				  const Standard_Real Tol,
@@ -151,6 +153,10 @@
 
 
 
+//=======================================================================
+//function : Perform
+//purpose  : 
+//=======================================================================
 void Extrema_ExtPElC::Perform (const gp_Pnt&       P, 
 			       const gp_Elips&     C,
 			       const Standard_Real Tol,
@@ -176,31 +182,57 @@
     cette equation.
 -----------------------------------------------------------------------------*/
 {
+  Standard_Integer NoSol, NbSol;
+  Standard_Real A, B, OPpMagn, aTx, aD2x, aTol2;
+  gp_Pnt aPx;
+  //
   myDone = Standard_False;
   myNbExt = 0;
-
-// 1- Projection du point P dans le plan de l ellipse -> Pp ...
-
+  //
+  aTol2=Tol*Tol;
+  //
+  // 0-
+  //modified by NIZNHY-PKV Fri Feb 13 09:37:33 2009f
+  aTx=ElCLib::Parameter(C, P);
+  aPx=ElCLib::Value(aTx, C);
+  aD2x=P.SquareDistance(aPx);
+  if (aD2x < aTol2) {
+    myDone = Standard_True;
+    myValue[myNbExt]=sqrt(aD2x);
+    myIsMin[myNbExt]=Standard_True;
+    myPoint[myNbExt]=Extrema_POnCurv(aTx ,aPx);
+    myNbExt=1;
+    return;
+  }
+  //modified by NIZNHY-PKV Fri Feb 13 09:37:37 2009t
+  //
+  // 1- Projection du point P dans le plan de l ellipse -> Pp ...
   gp_Pnt O = C.Location();
   gp_Vec Axe (C.Axis().Direction());
   gp_Vec Trsl = Axe.Multiplied(-(gp_Vec(O,P).Dot(Axe)));
   gp_Pnt Pp = P.Translated(Trsl);
-
-// 2- Calculs des solutions ...
-
-  Standard_Integer NoSol, NbSol;
-  Standard_Real A = C.MajorRadius();
-  Standard_Real B = C.MinorRadius();
+  //
+  // 2- Calculs des solutions ...
+  
+  //
+  A = C.MajorRadius();
+  B = C.MinorRadius();
+  
   gp_Vec OPp (O,Pp);
-  Standard_Real OPpMagn = OPp.Magnitude();
-  if (OPpMagn < Tol) { if (Abs(A-B) < Tol) { return; } }
+  OPpMagn = OPp.SquareMagnitude();
+  if (OPpMagn < aTol2) { 
+    if (Abs(A-B) < Tol) { 
+      return; 
+    } 
+  }
   Standard_Real X = OPp.Dot(gp_Vec(C.XAxis().Direction()));
   Standard_Real Y = OPp.Dot(gp_Vec(C.YAxis().Direction()));
   //  Standard_Real Y = Sqrt(OPpMagn*OPpMagn-X*X);
 
   Standard_Real ko2 = (B*B-A*A)/2., ko3 = -B*Y, ko4 = A*X;
-  if(Abs(ko3) < 1.e-16*Max(Abs(ko2), Abs(ko3))) ko3 = 0.0;
-
+  if(Abs(ko3) < 1.e-16*Max(Abs(ko2), Abs(ko3))) {
+    ko3 = 0.;
+  }
 //  math_TrigonometricFunctionRoots Sol(0.,(B*B-A*A)/2.,-B*Y,A*X,0.,Uinf,Usup);
   math_TrigonometricFunctionRoots Sol(0.,ko2, ko3, ko4, 0.,Uinf,Usup);
 
@@ -313,10 +345,7 @@
 	if (!DejaEnr) {
 	  TbExt[myNbExt] = Cu;
 	  myValue[myNbExt] = Cu.Distance(P);
-//  modified by NIZHNY-EAP Fri Oct 29 12:53:37 1999 ___BEGIN___
-//	  myIsMin[myNbExt] = (NoSol == 0);
 	  myIsMin[myNbExt] = myValue[myNbExt] < P.Distance(ElCLib::Value(Us+1,C));
-//  modified by NIZHNY-EAP Fri Oct 29 12:53:39 1999 ___END___
 	  myPoint[myNbExt] = Extrema_POnCurv(Us,Cu);
 	  myNbExt++;
 	}
@@ -407,10 +436,7 @@
       if (!DejaEnr) {
 	TbExt[myNbExt] = Cu;
 	myValue[myNbExt] = Cu.Distance(P);
-//  modified by NIZHNY-EAP Fri Oct 29 12:55:16 1999 ___BEGIN___
-//	myIsMin[myNbExt] = (NoSol == 0);
 	myIsMin[myNbExt] = myValue[myNbExt] < P.Distance(ElCLib::Value(Us+1,C));
-//  modified by NIZHNY-EAP Fri Oct 29 12:55:18 1999 ___END___
 	myPoint[myNbExt] = Extrema_POnCurv(Us,Cu);
 	myNbExt++;
       }
diff -Naur OpenCASCADE6.3.0/ros/src/GeomFill/GeomFill_NSections.cxx OpenCASCADE6.3.0sp6/ros/src/GeomFill/GeomFill_NSections.cxx
--- OpenCASCADE6.3.0/ros/src/GeomFill/GeomFill_NSections.cxx	2006-08-11 19:00:53.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/GeomFill/GeomFill_NSections.cxx	2009-10-03 01:04:05.000000000 +0200
@@ -942,6 +942,12 @@
         sameaxis = (C1.Axis().IsParallel(D,1.e-4));
       }
       isconic = samedir && linearrad && sameaxis;
+      //// Modified by jgv, 18.02.2009 for OCC20866 ////
+      Standard_Real first1 = AC1.FirstParameter(), last1 = AC1.LastParameter();
+      Standard_Real first2 = AC2.FirstParameter(), last2 = AC2.LastParameter();
+      isconic = (Abs(first1-first2) <= Precision::PConfusion() &&
+		 Abs(last1-last2)   <= Precision::PConfusion());
+      //////////////////////////////////////////////////
     }
   }
 
diff -Naur OpenCASCADE6.3.0/ros/src/IntPatch/IntPatch_PrmPrmIntersection.gxx OpenCASCADE6.3.0sp6/ros/src/IntPatch/IntPatch_PrmPrmIntersection.gxx
--- OpenCASCADE6.3.0/ros/src/IntPatch/IntPatch_PrmPrmIntersection.gxx	2008-07-18 16:59:37.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/IntPatch/IntPatch_PrmPrmIntersection.gxx	2009-10-03 01:04:13.000000000 +0200
@@ -32,14 +32,14 @@
 				     Standard_Real& u2,
 				     Standard_Real& v2);
 
-//xf
+
 static 
   void AdjustOnPeriodic(const TheSurface& Surf1,
 			const TheSurface& Surf2,
 			IntPatch_SequenceOfLine& aSLin);
-//xt
+
 //==================================================================================
-// function : Constructor
+// function : 
 // purpose  : 
 //==================================================================================
 IntPatch_PrmPrmIntersection::IntPatch_PrmPrmIntersection(): done(Standard_False)
@@ -1677,8 +1677,7 @@
 	    }
 	  }
 	}
-	//--printf("\n\n1 Dist3[0]=%5.5g,u3[0]=%5.5g,v3[0]=%5.5g ,  Dist3[1]=%5.5g,u3[1]=%5.5g,v3[1]=%5.5g  ,Dist3[2]=%5.5g,u3[2]=%5.5g,v3[2]=%5.5g\n",
-	//--       Dist3[0],u3[0],v3[0] ,  Dist3[1],u3[1],v3[1]  ,Dist3[2],u3[2],v3[2]);
+	//
 	Standard_Real U1_3 = (u3[0]+u3[1]+u3[2])/3.0;
 	Standard_Real V1_3 = (v3[0]+v3[1]+v3[2])/3.0;
 	
@@ -1712,8 +1711,7 @@
 	    }
 	  }
 	}
-	//printf("\n2 Dist3[0]=%5.5g,u3[0]=%5.5g,v3[0]=%5.5g ,  Dist3[1]=%5.5g,u3[1]=%5.5g,v3[1]=%5.5g  ,Dist3[2]=%5.5g,u3[2]=%5.5g,v3[2]=%5.5g\n",
-	//       Dist3[0],u3[0],v3[0] ,  Dist3[1],u3[1],v3[1]  ,Dist3[2],u3[2],v3[2]);
+	//
 	Standard_Real U2_3 = (u3[0]+u3[1]+u3[2])/3.0;
 	Standard_Real V2_3 = (v3[0]+v3[1]+v3[2])/3.0;
 	
@@ -1725,7 +1723,6 @@
     }
   }
   while(ok);
-  //-- cout<<"\n *** "<<Compt<<" Points de *1  ** 2* ds la grille UVP"<<ComptTrouve<<endl; Compt=0;
 }
 
 //==================================================================================
@@ -1764,7 +1761,7 @@
     if (ClearFlag)
       SLin.Clear();
     // modified by NIZHNY-AMV  Tue Oct 18 12:37:02 2005.END
-
+    //
     //IntPolyh_Intersection Interference(Surf1,NbU1,NbV1,Surf2,NbU2,NbV2);
     //     IntPolyh_Intersection Interference(Surf1, anUpars1, aVpars1, 
     // 				       Surf2, anUpars2, aVpars2);
@@ -1775,15 +1772,16 @@
       pInterference = new IntPolyh_Intersection(Surf1,NbU1,NbV1,Surf2,NbU2,NbV2);
     }
     else {
-      pInterference = new IntPolyh_Intersection( Surf1, anUpars1, aVpars1, 
+      pInterference = new IntPolyh_Intersection(Surf1, anUpars1, aVpars1, 
 						Surf2, anUpars2, aVpars2 );
     }
     if ( !pInterference ) {
       done = Standard_False;
       return;
     }
+    //
     IntPolyh_Intersection& Interference = *pInterference;
-
+    //
     done = Interference.IsDone();
     if( !done ) {
       if ( pInterference ) {
@@ -1792,7 +1790,7 @@
       }
       return;
     }
-
+    
     Standard_Real Deflection2 = Deflection*Deflection;
     Standard_Integer nbLigSec = Interference.NbSectionLines();
     Standard_Integer nbTanZon = Interference.NbTangentZones();
@@ -1828,11 +1826,18 @@
 	  }
 	}
       } while(triok==Standard_False);
-
+      //
       for( ls = 1; ls <= nbLigSec; ls++) {
-	Standard_Integer nbp = Interference.NbPointsInLine(TabL[ls]);
-	Standard_Integer *TabPtDep = new Standard_Integer [nbp+1];
-	Standard_Integer ilig;
+	Standard_Integer nbp, ilig, *TabPtDep;
+	//
+	nbp = Interference.NbPointsInLine(TabL[ls]);
+	//modified by NIZNHY-PKV Fri Sep  5 15:19:28 2008f
+	if (!nbp) {
+	  continue;
+	}
+	//modified by NIZNHY-PKV Fri Sep  5 15:19:31 2008t
+	TabPtDep = new Standard_Integer [nbp+1];
+	//
 	for( ilig = 1; ilig <= nbp; ilig++ )
 	  TabPtDep[ilig]=0;
 
@@ -1864,9 +1869,8 @@
 	Standard_Integer nbps2 = (nbp>3)? (nbp/2) :  1;
 	Standard_Integer NombreDePointsDeDepartDuCheminement = 0;
 	Standard_Boolean lignetrouvee=Standard_False;
-	// const Standard_Integer NbDePointsDeDepartDuChmLimit = 3;
 	const Standard_Integer NbDePointsDeDepartDuChmLimit = 5;
-
+	//
 	do { 
 	  NombreDePointsDeDepartDuCheminement++;
 	  switch (NombreDePointsDeDepartDuCheminement) {
@@ -1891,7 +1895,7 @@
 	    nbps2 = NombreDePointsDeDepartDuCheminement-3;
 	    NombreDePointsDeDepartDuCheminement++;
 	  }
-
+	  //
 	  if(TabPtDep[nbps2] == 0) {
 	    TabPtDep[nbps2] = 1;
 	    Interference.GetLinePoint(TabL[ls],nbps2,_x,_y,_z,U1,V1,U2,V2,incidence);
@@ -1966,7 +1970,6 @@
 		Standard_Boolean bPWIsDone;
 		Standard_Integer iPWNbPoints, aNbPointsVer;
 		Standard_Real aD11, aD12, aD21, aD22, aDx;
-
 		//
 		bPWIsDone=PW.IsDone();
 		//xt
@@ -2023,12 +2026,8 @@
 			  }
 			}
 		      }
-// 		      if(Point3dDebut.Distance(verPointDebut.Value()) <= TolTangency) { 
-// 			if(Point3dFin.Distance(verPointFin.Value()) <= TolTangency)
-// 			  RejetLigne = Standard_True; 
-// 		      }
 		    }
-		    
+		    //
 		    if(!RejetLigne) {
 		      IntSurf_TypeTrans trans1,trans2;
 		      Standard_Real locu,locv;
@@ -2227,10 +2226,9 @@
       delete [] TabL;
 
     }// if nbLigSec >= 1
-
-    //xf
+    //
     AdjustOnPeriodic(Surf1, Surf2, SLin);
-    //xt
+    //
 
     //--------------------------------------------------------------------
     //-- Calcul des parametres approches a partir des Zones De Tangence --
diff -Naur OpenCASCADE6.3.0/ros/src/IntTools/IntTools_BeanBeanIntersector.cxx OpenCASCADE6.3.0sp6/ros/src/IntTools/IntTools_BeanBeanIntersector.cxx
--- OpenCASCADE6.3.0/ros/src/IntTools/IntTools_BeanBeanIntersector.cxx	2007-06-22 16:09:36.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/IntTools/IntTools_BeanBeanIntersector.cxx	2009-10-03 01:04:14.000000000 +0200
@@ -297,6 +297,41 @@
   aCriteria2=myCriteria*myCriteria;
   aNbRanges=myRangeManager.Length();
   //
+  //modified by NIZNHY-PKV Tue Mar 24 11:13:42 2009f
+  {
+    GeomAbs_CurveType aCT1, aCT2;
+    //
+    aCT1=myCurve1.GetType();
+    aCT2=myCurve2.GetType();
+    
+    if (aCT1==GeomAbs_BSplineCurve &&
+	aCT2==GeomAbs_BSplineCurve) {
+      Standard_Real aST, aST1, aSx, aSz;
+      //
+      aST1=myLastParameter1-myFirstParameter1;
+      if (aST1>aPPC) {
+	aSz=1.e-4;
+	aST=0.;
+	for(i=1; i<=aNbRanges; ++i) {
+	  iFlag=myRangeManager.Flag(i);
+	  if(iFlag==4) {
+	    aRange=myRangeManager.Range(i);
+	    aST=aST+aRange.Last()-aRange.First();
+	  }
+	}
+	aSx=1.-aST/aST1;
+	if (aSx<aSz) {
+	  aRange.SetFirst(myFirstParameter1);
+	  aRange.SetLast(myLastParameter1);
+	  myResults.Append(aRange);
+	  myIsDone = Standard_True;
+	  return;
+	}
+      }
+    }
+  }
+  //modified by NIZNHY-PKV Tue Mar 24 11:13:44 2009t
+  //
   for(i=1; i<=aNbRanges; ++i) {
     iFlag=myRangeManager.Flag(i);
     //
@@ -621,18 +656,10 @@
 	      anExtrema.Points(k, P1, P2);
 	      aPrm1=P1.Parameter();
 	      aPrm2=P2.Parameter();
-	      //modified by NIZNHY-PKV Tue Jun  5 15:47:13 2007f
-	      /*
-	      if((aPrm1 >= 0.) && (aPrm1 <= aDistance) &&
-		 (aPrm2 >= 0.) && (aPrm2 <= aD)) {
-		isintersection = Standard_True;
-	      }
-	      */
 	      if((aPrm1 >= -aMaxDistance) && (aPrm1 <= aDistance+aMaxDistance) &&
 		 (aPrm2 >= -aMaxDistance) && (aPrm2 <= aD+aMaxDistance)) {
 		isintersection = Standard_True;
 	      }
-	      //modified by NIZNHY-PKV Tue Jun  5 15:47:17 2007t
 	      else { // 2
 		Extrema_ExtPElC aPointProjector;
 
diff -Naur OpenCASCADE6.3.0/ros/src/IntTools/IntTools_FaceFace.cxx OpenCASCADE6.3.0sp6/ros/src/IntTools/IntTools_FaceFace.cxx
--- OpenCASCADE6.3.0/ros/src/IntTools/IntTools_FaceFace.cxx	2008-07-18 16:59:40.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/IntTools/IntTools_FaceFace.cxx	2009-10-03 01:04:14.000000000 +0200
@@ -1,8 +1,4 @@
-//  Modified by skv - Tue Jul 11 16:41:33 2006 OCC12627
-//  Modified by skv - Mon Jul 12 16:16:15 2004 OCC6277
-//  Modified by ofv - Mon Nov  9 16:31:15 2004 OCC6766 fix
-//  Modified by ofv - Mon Dec 23 16:31:15 2004 OCC6766 fix reg
-
+ 
 #include <IntTools_FaceFace.ixx>
 #include <BRep_Tool.hxx>
 #include <IntTools_Curve.hxx>
@@ -101,6 +97,7 @@
 #include <TColgp_SequenceOfPnt2d.hxx>
 #include <TColStd_HArray1OfReal.hxx>
 #include <GeomAdaptor_Curve.hxx>
+#include <IntSurf_PntOn2S.hxx>
 
 static
   void TolR3d(const TopoDS_Face& ,
@@ -341,7 +338,7 @@
   void IntTools_FaceFace::Perform(const TopoDS_Face& F1,
 				  const TopoDS_Face& F2)
 {
-  Standard_Boolean hasCone, RestrictLine, bIsDone;
+  Standard_Boolean RestrictLine, bIsDone, hasCone;
   Standard_Integer aNbLin, aNbPnts, i;
   Standard_Real TolArc, TolTang, Deflection, UVMaxStep;
   Standard_Real umin, umax, vmin, vmax;
@@ -426,25 +423,11 @@
     // 
     myHS1->ChangeSurface().Load(S1, umin, umax, vmin, vmax);
     //
-    //modified by NIZNHY-PKV Thu Jul  3 14:50:28 2008f
-    /*
-    if(S1==S2) { 
-      myHS2 = myHS1; 
-    }
-    else {
-      BRepTools::UVBounds(F2, umin, umax, vmin, vmax);
-	// 
-      CorrectSurfaceBoundaries(F2, (aTolF1 + aTolF2) * 2., umin, umax, vmin, vmax);
-	//   
-      myHS2->ChangeSurface().Load(S2, umin, umax, vmin, vmax);
-    }
-    */
     BRepTools::UVBounds(F2, umin, umax, vmin, vmax);
     // 
     CorrectSurfaceBoundaries(F2, (aTolF1 + aTolF2) * 2., umin, umax, vmin, vmax);
     //   
     myHS2->ChangeSurface().Load(S2, umin, umax, vmin, vmax);
-    //modified by NIZNHY-PKV Thu Jul  3 14:50:36 2008t
   }
   //
   dom1 = new IntTools_TopolTool(myHS1);
@@ -452,7 +435,17 @@
   //
   myLConstruct.Load(dom1, dom2, myHS1, myHS2);
   //
+  //Deflection = 0.085;
   Deflection = (hasCone) ? 0.085 : 0.1;
+  //modified by NIZNHY-PKV Fri Feb 20 09:10:17 2009f
+  if (aType1==GeomAbs_BSplineSurface &&
+      aType2==GeomAbs_BSplineSurface) {
+    if (myHS1->IsUClosed() && myHS1->IsUPeriodic() &&
+	myHS2->IsUClosed() && myHS2->IsUPeriodic()) {
+      Deflection=0.085;
+    }
+  }
+  //modified by NIZNHY-PKV Fri Feb 20 09:12:11 2009t
   UVMaxStep  = 0.001;
   //
   myIntersector.SetTolerances(TolArc, TolTang, UVMaxStep, Deflection);
@@ -496,18 +489,7 @@
       }
     }
   }
-  //
-  //modified by NIZNHY-PKV Thu Jul  3 14:51:04 2008f
-  /*
-  if(myHS1 == myHS2) { 
-    myIntersector.Perform(myHS1, dom1, TolArc, TolTang);
-  }
-  else {
-    myIntersector.Perform(myHS1, dom1, myHS2, dom2, TolArc, TolTang, myListOfPnts, RestrictLine);
-  }
-  */
   myIntersector.Perform(myHS1, dom1, myHS2, dom2, TolArc, TolTang, myListOfPnts, RestrictLine);
-  //modified by NIZNHY-PKV Thu Jul  3 14:51:09 2008t
   //
   bIsDone=myIntersector.IsDone();
   if (bIsDone) {
@@ -648,6 +630,18 @@
     if(!myListOfPnts.IsEmpty()) {
       bAvoidLineConstructor = Standard_True;
     }
+
+    Standard_Integer nbp = aWLine->NbPnts();
+    const IntSurf_PntOn2S& p1 = aWLine->Point(1);
+    const IntSurf_PntOn2S& p2 = aWLine->Point(nbp);
+
+    const gp_Pnt& P1 = p1.Value();
+    const gp_Pnt& P2 = p2.Value();
+
+    if(P1.SquareDistance(P2) < 1.e-14) {
+      bAvoidLineConstructor = Standard_False;
+    }
+
   }
   //
   // Line Constructor
@@ -1320,14 +1314,14 @@
 	GeomAbs_SurfaceType typs1, typs2;
 	typs1 = myHS1->Surface().GetType();
 	typs2 = myHS2->Surface().GetType();
-	
+	//
 	if(typs1 == GeomAbs_Plane) { 
 	  theapp3d.Perform(myHS1, myHS2, WL, Standard_False,Standard_True, myApprox2,ifprm,ilprm);
 	}	  
 	else if(typs2 == GeomAbs_Plane) { 
 	  theapp3d.Perform(myHS1,myHS2,WL,Standard_False,myApprox1,Standard_True,ifprm,ilprm);
 	}
-	else { 
+	else {
 	  //
 	  if (myHS1 != myHS2){
 	    if ((typs1==GeomAbs_BezierSurface || typs1==GeomAbs_BSplineSurface) &&
@@ -2321,76 +2315,7 @@
   return !bFlag;
 }
 
-//=========================================================================
-// static function : ComputePurgedWLine
-// purpose : Removes equal points (leave one of equal points) from theWLine
-//           and recompute vertex parameters.
-//           Returns new WLine or null WLine if the number
-//           of the points is less than 2.
-//=========================================================================
-Handle(IntPatch_TheWLineOfIntersection) ComputePurgedWLine(const Handle(IntPatch_TheWLineOfIntersection)& theWLine) {
-  Handle(IntPatch_TheWLineOfIntersection) aResult;
-  Handle(IntPatch_TheWLineOfIntersection) aLocalWLine;
-  Handle(IntPatch_TheWLineOfIntersection) aTmpWLine = theWLine;
-
-  Handle(IntSurf_LineOn2S) aLineOn2S = new IntSurf_LineOn2S();
-  aLocalWLine = new IntPatch_TheWLineOfIntersection(aLineOn2S, Standard_False);
-  Standard_Integer i, k, v, nb, nbvtx;
-  nbvtx = theWLine->NbVertex();
-  nb = theWLine->NbPnts();
-
-  for(i = 1; i <= nb; i++) {
-    aLineOn2S->Add(theWLine->Point(i));
-  }
-
-  for(v = 1; v <= nbvtx; v++) {
-    aLocalWLine->AddVertex(theWLine->Vertex(v));
-  }
-  
-  for(i = 1; i <= aLineOn2S->NbPoints(); i++) {
-    Standard_Integer aStartIndex = i + 1;
-    Standard_Integer anEndIndex = i + 5;
-    nb = aLineOn2S->NbPoints();
-    anEndIndex = (anEndIndex > nb) ? nb : anEndIndex;
-
-    if((aStartIndex >= nb) || (anEndIndex <= 1)) {
-      continue;
-    }
-    k = aStartIndex;
-
-    while(k <= anEndIndex) {
-      
-      if(i != k) {
-	IntSurf_PntOn2S p1 = aLineOn2S->Value(i);
-	IntSurf_PntOn2S p2 = aLineOn2S->Value(k);
-	
-	if(p1.Value().IsEqual(p2.Value(), gp::Resolution())) {
-	  aTmpWLine = aLocalWLine;
-	  aLocalWLine = new IntPatch_TheWLineOfIntersection(aLineOn2S, Standard_False);
-
-	  for(v = 1; v <= aTmpWLine->NbVertex(); v++) {
-	    IntPatch_ThePointOfIntersection aVertex = aTmpWLine->Vertex(v);
-	    Standard_Integer avertexindex = (Standard_Integer)aVertex.ParameterOnLine();
-
-	    if(avertexindex >= k) {
-	      aVertex.SetParameter(aVertex.ParameterOnLine() - 1.);
-	    }
-	    aLocalWLine->AddVertex(aVertex);
-	  }
-	  aLineOn2S->RemovePoint(k);
-	  anEndIndex--;
-	  continue;
-	}
-      }
-      k++;
-    }
-  }
 
-  if(aLineOn2S->NbPoints() > 1) {
-    aResult = aLocalWLine;
-  }
-  return aResult;
-}
 
 //=======================================================================
 //function : TolR3d
@@ -3711,3 +3636,86 @@
 
   return Standard_True;
 }
+//modified by NIZNHY-PKV Thu Feb 12 11:54:18 2009f
+//=========================================================================
+// static function : ComputePurgedWLine
+// purpose : Removes equal points (leave one of equal points) from theWLine
+//           and recompute vertex parameters.
+//           Returns new WLine or null WLine if the number
+//           of the points is less than 2.
+//=========================================================================
+Handle(IntPatch_TheWLineOfIntersection) 
+     ComputePurgedWLine(const Handle(IntPatch_TheWLineOfIntersection)& theWLine) 
+{
+  Standard_Integer i, k, v, nbvtx, aStartIndex, anEndIndex, avertexindex, aNbP;
+  Standard_Real aD2, aTol2;
+  Handle(IntPatch_TheWLineOfIntersection) aResult, aLocalWLine, aTmpWLine;
+  Handle(IntSurf_LineOn2S) aLineOn2S;
+  IntSurf_PntOn2S p1, p2;
+  //
+  aTol2=gp::Resolution();// ? but it was so
+  //
+  aLineOn2S = new IntSurf_LineOn2S();
+  aLocalWLine = new IntPatch_TheWLineOfIntersection(aLineOn2S, Standard_False);
+  //
+  aNbP = theWLine->NbPnts();
+  for(i = 1; i <= aNbP; i++) {
+    aLineOn2S->Add(theWLine->Point(i));
+  }
+  //
+  nbvtx = theWLine->NbVertex();
+  for(v = 1; v <= nbvtx; v++) {
+    aLocalWLine->AddVertex(theWLine->Vertex(v));
+  }
+  //
+  aTmpWLine = theWLine;
+  aNbP=aLineOn2S->NbPoints();
+  for(i = 1; i <= aNbP; i++) {
+    aStartIndex = i + 1;
+    anEndIndex = i + 5;
+    //
+    anEndIndex = (anEndIndex > aNbP) ? aNbP : anEndIndex;
+    //if((aStartIndex >= aNbP) || (anEndIndex <= 1)) {//ft
+    if((aStartIndex > aNbP) || (anEndIndex <= 1)) {
+      continue;
+    }
+    //
+    k = aStartIndex;
+    while(k <= anEndIndex) {
+      if(i != k) {
+	p1 = aLineOn2S->Value(i);
+	p2 = aLineOn2S->Value(k);
+	const gp_Pnt& aP1=p1.Value();
+	const gp_Pnt& aP2=p2.Value();
+	aD2=aP1.SquareDistance(aP2);
+	if (aD2<aTol2) {
+	  aTmpWLine = aLocalWLine;
+	  aLocalWLine = new IntPatch_TheWLineOfIntersection(aLineOn2S, Standard_False);
+
+	  for(v = 1; v <= aTmpWLine->NbVertex(); v++) {
+	    IntPatch_ThePointOfIntersection aVertex = aTmpWLine->Vertex(v);
+	    avertexindex = (Standard_Integer)aVertex.ParameterOnLine();
+
+	    if(avertexindex >= k) {
+	      aVertex.SetParameter(aVertex.ParameterOnLine() - 1.);
+	    }
+	    aLocalWLine->AddVertex(aVertex);
+	  }
+	  //
+	  aLineOn2S->RemovePoint(k);
+	  aNbP=aLineOn2S->NbPoints();
+	  anEndIndex--;
+	  continue;
+	} //if (aD2<aTol2) 
+      } //if(i != k)
+      k++;
+    } //while(k <= anEndIndex) 
+  } //
+  //
+  aNbP=aLineOn2S->NbPoints();
+  if(aNbP>1) {
+    aResult = aLocalWLine;
+  }
+  return aResult;
+}
+//modified by NIZNHY-PKV Thu Feb 12 11:54:21 2009t
diff -Naur OpenCASCADE6.3.0/ros/src/IntTools/IntTools_Tools.cxx OpenCASCADE6.3.0sp6/ros/src/IntTools/IntTools_Tools.cxx
--- OpenCASCADE6.3.0/ros/src/IntTools/IntTools_Tools.cxx	2007-06-08 16:33:26.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/IntTools/IntTools_Tools.cxx	2009-10-03 01:04:14.000000000 +0200
@@ -199,7 +199,7 @@
   Standard_Integer IntTools_Tools::SplitCurve(const IntTools_Curve& IC,
 					      IntTools_SequenceOfCurves& aCvs)
 {
-  Handle (Geom_Curve)   aC3D =IC.Curve();
+  Handle (Geom_Curve) aC3D =IC.Curve();
   if(aC3D.IsNull())
     return 0;
   //
@@ -213,11 +213,21 @@
   }
 
   Standard_Real aF, aL, aMid;
-
+  
+  //
   aF=aC3D->FirstParameter();
-  aL=aC3D-> LastParameter();
+  aL=aC3D->LastParameter();
   aMid=0.5*(aF+aL);
-
+  //modified by NIZNHY-PKV Thu Feb  5 08:26:58 2009 f
+  GeomAdaptor_Curve aGAC(aC3D);
+  GeomAbs_CurveType aCT=aGAC.GetType();
+  if (aCT==GeomAbs_BSplineCurve ||
+      aCT==GeomAbs_BezierCurve) {
+    //aMid=0.5*aMid;
+    aMid=IntTools_Tools::IntermediatePoint(aF, aL);
+  }
+  //modified by NIZNHY-PKV Thu Feb  5 08:27:00 2009 t
+  //
   Handle(Geom_Curve) aC3DNewF, aC3DNewL;
   aC3DNewF =new Geom_TrimmedCurve  (aC3D, aF, aMid);
   aC3DNewL =new Geom_TrimmedCurve  (aC3D, aMid, aL);
diff -Naur OpenCASCADE6.3.0/ros/src/InterfaceGraphic/InterfaceGraphic_tgl_all.h OpenCASCADE6.3.0sp6/ros/src/InterfaceGraphic/InterfaceGraphic_tgl_all.h
--- OpenCASCADE6.3.0/ros/src/InterfaceGraphic/InterfaceGraphic_tgl_all.h	2003-02-04 07:34:21.000000000 +0100
+++ OpenCASCADE6.3.0sp6/ros/src/InterfaceGraphic/InterfaceGraphic_tgl_all.h	2009-10-03 01:04:14.000000000 +0200
@@ -9,11 +9,16 @@
 #ifndef  INTERFACEGRAPHIC_TGL_ALL_H
 #define  INTERFACEGRAPHIC_TGL_ALL_H
 
-typedef  int   Tint;
-typedef  float Tfloat;
-typedef  char  Tchar;
-typedef  char  Tbool;
-typedef unsigned int    Tuint;
+typedef  int          Tint;
+typedef  float        Tfloat;
+/* PCD 04/07/07  */
+typedef	 double       Tdouble;
+/* Tchar is treated as a signed char in visualization code,
+therefore it should be made signed explicitly, as on Linux 
+-funsigned-char option is specified when building OCCT */
+typedef  signed char  Tchar;
+typedef  char         Tbool;
+typedef  unsigned int Tuint;
 
 #define  TGL_SP   1
 #define  TGL_DP   0
@@ -37,6 +42,7 @@
 #define  TNotDone  0
 
 typedef  Tfloat  Tmatrix3[4][4];
+
 typedef  enum    
 { 
   TPreConcatenate, 
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_GraphicDriver.cxx OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_GraphicDriver.cxx
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_GraphicDriver.cxx	2008-06-02 16:04:17.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_GraphicDriver.cxx	2009-10-03 01:04:22.000000000 +0200
@@ -1,38 +1,38 @@
+/*
+ File         OpenGl_GraphicDriver.cxx
+ Created      Mardi 28 janvier 1997
+ Author       CAL
 
-// File         OpenGl_GraphicDriver.cxx
-// Created      Mardi 28 janvier 1997
-// Author       CAL
+-Copyright    MatraDatavision 1997
 
-//-Copyright    MatraDatavision 1997
+-Version      
 
-//-Version      
+-Design       Declaration des variables specifiques aux Drivers
+-Warning      Un driver encapsule les Pex, Phigs et OpenGl drivers
 
-//-Design       Declaration des variables specifiques aux Drivers
+-References   
 
-//-Warning      Un driver encapsule les Pex, Phigs et OpenGl drivers
+-Language     C++ 2.0
 
-//-References   
+-Declarations
 
-//-Language     C++ 2.0
-
-//-Declarations
-
-// for the class
+ for the class
+*/
 #include <OpenGl_GraphicDriver.ixx>
 
 #ifdef WNT
 #include <malloc.h>
 #endif
-
-//-Aliases
-
-//-Global data definitions
-
-// Pour eviter de "mangler" MetaGraphicDriverFactory, le nom de la
-// fonction qui cree un Graphic3d_GraphicDriver.
-// En effet, ce nom est recherche par la methode DlSymb de la
-// classe OSD_SharedLibrary dans la methode SetGraphicDriver de la
-// classe Graphic3d_GraphicDevice
+/*
+-Aliases
+-Global data definitions
+
+ Pour eviter de "mangler" MetaGraphicDriverFactory, le nom de la
+ fonction qui cree un Graphic3d_GraphicDriver.
+ En effet, ce nom est recherche par la methode DlSymb de la
+ classe OSD_SharedLibrary dans la methode SetGraphicDriver de la
+ classe Graphic3d_GraphicDevice
+*/
 extern "C" {
 #ifdef WNT /* disable MS VC++ warning on C-style function returning C++ object */
 #pragma warning(push)
@@ -44,22 +44,25 @@
                 (const Standard_CString AShrName) {
                   Handle(OpenGl_GraphicDriver)  aOpenDriver = new OpenGl_GraphicDriver (AShrName);
                   return aOpenDriver;
-//              return new OpenGl_GraphicDriver (AShrName);
+/*              return new OpenGl_GraphicDriver (AShrName);  */
         }
 #ifdef WNT
 #pragma warning(pop)
 #endif
 }
 
-//-Constructors
+/*-Constructors   */
 
 OpenGl_GraphicDriver::OpenGl_GraphicDriver (const Standard_CString AShrName):Graphic3d_GraphicDriver (AShrName) 
 {
-
+  /* Change this if traceing OpenGl_GraphicDriver method calls is needed      */
+#if 0
+	SetTrace(1);
+#endif
+	
 #ifdef WNT
     _set_sbh_threshold(1016);
 #endif
-  
 }
 
-//-Methods, in order
+/*-Methods, in order    */
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_LightBox.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_LightBox.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_LightBox.c	2001-09-21 09:57:39.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_LightBox.c	2009-10-03 01:04:22.000000000 +0200
@@ -56,8 +56,10 @@
 /*
  * Constantes
  */
-
+#ifndef DEBUG
 #define DEBUG 0
+#endif
+
 #define NO_PRINT_DEBUG
 
 #define GROW_SIZE_WKS 10
@@ -554,16 +556,12 @@
 void LightOn(void)
 {
 #ifdef PRINT_DEBUG
-    if (!lightOn)
-	printf("LightOn() \n");
-    else
-	printf("LightOn() inutile \n");
+  if(IsLightOn())
+    printf("LightOn(): lighting already enabled!");
+  else
+    printf("LightOn() succeeded");
 #endif
-    if (!lightOn)
-    {
-	glEnable(GL_LIGHTING);
-	lightOn = GL_TRUE;
-    }
+  glEnable(GL_LIGHTING);
 }
 
 
@@ -574,16 +572,12 @@
 void LightOff(void)
 {
 #ifdef PRINT_DEBUG
-    if (lightOn)
-	printf("LightOff() \n");
-    else
-	printf("LightOff() inutile \n");
+  if(!IsLightOn())
+    printf("LightOff(): lighting already disabled!");
+  else
+    printf("LightOff() succeeded");
 #endif
-    if (lightOn)
-    {
-	glDisable(GL_LIGHTING);
-	lightOn = GL_FALSE;
-    }
+  glDisable(GL_LIGHTING);
 }
 /*-----------------------------------------------------------------*/
 
@@ -593,6 +587,6 @@
  
 GLboolean IsLightOn(void)
 {
-   return (lightOn);
+   return glIsEnabled(GL_LIGHTING);
 }
 /*-----------------------------------------------------------------*/
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_PrimitiveArray.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_PrimitiveArray.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_PrimitiveArray.c	2008-08-15 15:54:06.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_PrimitiveArray.c	2009-10-03 01:04:23.000000000 +0200
@@ -473,7 +473,7 @@
 				if( pfc ) glColor3fv  ( pfc[i].rgb  );
 				if( renderMode == GL_FEEDBACK )
 					draw_primitive_elements( p, draw_mode, p->bounds[i], 
-                                 GL_UNSIGNED_INT, (GLenum*) &p->edges[n]);
+                                 GL_UNSIGNED_INT,(GLenum*) &p->edges[n]);
 				else
 					glDrawElements( draw_mode, p->bounds[i], 
                                GL_UNSIGNED_INT, &p->edges[n]);
@@ -493,7 +493,7 @@
 	  } else if( p->num_edges > 0 ) {
 			if( renderMode == GL_FEEDBACK )
 				draw_primitive_elements( p, draw_mode, p->num_edges, 
-                                  GL_UNSIGNED_INT, (GLenum*) &p->edges[0]);
+                                  GL_UNSIGNED_INT,(GLenum*) &p->edges[0]);
 			else
 				glDrawElements( draw_mode, p->num_edges, 
                                 GL_UNSIGNED_INT, p->edges);
@@ -809,8 +809,8 @@
 {
     Tint    i, j, n;
     Tint    edge_type=0, line_type_preserve=0;
-    Tfloat  edge_width=0, line_width_preserve=0;
-    /*GLboolean texture_on;*/
+    Tfloat  edge_width=0, line_width_preserve=0; 
+    /* GLboolean texture_on;*/
 
 	GLint renderMode;
     
@@ -875,7 +875,7 @@
 #endif
 		  if( renderMode == GL_FEEDBACK )
 				draw_primitive_elements( p, draw_mode, p->bounds[i], 
-                                 GL_UNSIGNED_INT, (GLenum*) &p->edges[n]);
+                                 GL_UNSIGNED_INT, (GLenum*)&p->edges[n]);
 		  else
 				glDrawElements( draw_mode, p->bounds[i], 
                                 GL_UNSIGNED_INT, &p->edges[n]);
@@ -903,7 +903,7 @@
 #endif
 	  if( renderMode == GL_FEEDBACK )
 			draw_primitive_elements( p, draw_mode, p->num_edges, 
-                                GL_UNSIGNED_INT, (GLenum*) p->edges);
+                                GL_UNSIGNED_INT,(GLenum*) p->edges);
 	  else
 			glDrawElements( draw_mode, p->num_edges, 
                                 GL_UNSIGNED_INT, p->edges);
@@ -1641,7 +1641,7 @@
           for( i=n=0 ; i<p->num_bounds ; i++ ) {
 			if( renderMode == GL_FEEDBACK )
 				draw_primitive_elements( p, draw_mode, p->bounds[i], 
-                                GL_UNSIGNED_INT, (GLenum*) &p->edges[n]);
+                                GL_UNSIGNED_INT,(GLenum*) &p->edges[n]);
 			else
 				glDrawElements( draw_mode, p->bounds[i],
                                 GL_UNSIGNED_INT, &p->edges[n]);
@@ -1659,7 +1659,7 @@
       } else if( p->num_edges > 0 ) {
 		if( renderMode == GL_FEEDBACK )
 			draw_primitive_elements( p, draw_mode, p->num_edges, 
-                                GL_UNSIGNED_INT, (GLenum*) p->edges);
+                                GL_UNSIGNED_INT,(GLenum*) p->edges);
 		else
 			glDrawElements( draw_mode, p->num_edges,
                                 GL_UNSIGNED_INT, p->edges);
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_attri.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_attri.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_attri.c	2008-06-27 17:50:05.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_attri.c	2009-10-03 01:04:22.000000000 +0200
@@ -57,11 +57,11 @@
 ************************************************************************/
 
 #define BUC60577        /*GG_101099     Enable to compute correctly
-//                      transparency with more than one object in the view.
+                      transparency with more than one object in the view.  
 */
 
 #define IMP190100       /*GG     Push and Pop polyline type and width
-//                      attributes correctly.
+                      attributes correctly.
 */
 
 #define G003            /*EUG   degeneration mode management
@@ -192,8 +192,8 @@
     TEL_ALIGN_DATA  TextAlign;
 /*OCC7456 abd 14.12.2004 Text alingnment attributes  */
     Tint            PolymarkerType;
-    Tint            InteriorReflectanceEquation;
-    Tint            BackInteriorReflectanceEquation;
+    Tint   InteriorReflectanceEquation;
+    Tint   BackInteriorReflectanceEquation;
     TEL_SURF_PROP   SurfaceAreaProperties;
     TEL_SURF_PROP   BackSurfaceAreaProperties;
     TelCullMode     FaceCullingMode;
@@ -267,8 +267,8 @@
       0 }, /*Vertical Text Alignment*/
     /*OCC7456 abd 14.12.2004 Text alingnment attributes  */
     TEL_PM_PLUS,            /* PolymarkerType */
-    CALL_PHIGS_REFL_NONE,      /* InteriorReflectanceEquation */
-    CALL_PHIGS_REFL_NONE,      /* BackInteriorReflectanceEquation */
+    CALL_PHIGS_REFL_NONE,          /* InteriorReflectanceEquation */
+    CALL_PHIGS_REFL_NONE,          /* BackInteriorReflectanceEquation */
     { 0.2F, 0.8F, 0.1F, 0.0F,  /* Coef d eclairage */
       1.0F, 10.0F, 0.0F,  
       1,  1,  1,  0, 0,          /* Etat des eclairage */
@@ -849,7 +849,7 @@
 #ifdef GER61394
                         if( antiAliasingMode & 2 ) glEnable(GL_POLYGON_SMOOTH);
 #endif
-                        glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 
+						glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 
                         glEnable (GL_BLEND);
                     }
                 }
@@ -1454,7 +1454,7 @@
 	    /* ABD 29/10/04  Transform Persistence of Presentation( pan, zoom, rotate ) */
 	    /*case TelTransformPersistenceFlag:	      
 	      k[ i ] -> data.ldata = attri_tail->TransPersFlag;
-              //transform_persistence_begin( attri_tail->TransPersFlag );
+              transform_persistence_begin( attri_tail->TransPersFlag );     
 	      break;
             */
             case  TelTransformPersistence:
@@ -1539,7 +1539,7 @@
     printf(" controle mode rm == CALL_PHIGS_REFL_NONE : %d\n",  rm == CALL_PHIGS_REFL_NONE);
 #endif
 
-    if( rm == CALL_PHIGS_REFL_NONE ) return;
+    if( rm == CALL_PHIGS_REFL_NONE ) return; 
 
     /* 
      * Gestion de la transparence 
@@ -1785,7 +1785,7 @@
         }
         else
         {
-            newDiff3 = 1.0F;
+                      newDiff3 = 1.0F;
             if (SecondPassDo)
             {
                 newDiff3 = prop->env_reflexion; 
@@ -1803,11 +1803,24 @@
 	       differs from the previous value  */
             if (  mDiff[0] != 0.0 || mDiff[1] != 0.0 || mDiff[2] != 0.0 
                   || fabs(mDiff[3] - newDiff3) > 0.01 )
+
             {
                 mDiff[0] = 0.0F;
                 mDiff[1] = 0.0F;
                 mDiff[2] = 0.0F;
                 mDiff[3] = newDiff3;
+            
+                if (SecondPassDo)
+                {
+                    mDiff[3] = prop->env_reflexion; 
+                }
+                else
+                {
+                    if (need_trans) mDiff[3] = prop->trans;
+                    /* si le materiau reflechi la scene environnante,
+                       alors il faudra faire une seconde passe */
+                    if (prop->env_reflexion != 0.0) SecondPassNeeded = 1;
+                }
 
                 glMaterialfv(face, GL_DIFFUSE, mDiff);
 #ifdef TRACE_MATERIAL
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_execstruct.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_execstruct.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_execstruct.c	2005-09-16 19:35:46.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_execstruct.c	2009-10-03 01:04:23.000000000 +0200
@@ -28,8 +28,11 @@
   	   16-06-2000 : ATS,GG : G005 : Some conditions for execution of PARRAY  primitives
 
 ************************************************************************/
+#ifdef DEBUG
+#define TRACE
+#define TRACE_EXEC
+#endif
 
-#define xTRACE
 #define G003	/* EUG 16-09-99 G003 ZBufferAuto treatment 
 */
 
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_initelem.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_initelem.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_initelem.c	2005-09-16 19:35:47.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_initelem.c	2009-10-03 01:04:22.000000000 +0200
@@ -982,14 +982,14 @@
    Tint         i, k1, k2, offset;
    unsigned     char raster[] = {
 
-                                          0x08,0x00,
-                                          0x08,0x00,
-                                          0x08,0x00,
-                                          0x08,0x00,
-                                          0xff,0x80,
-                                          0x08,0x00,
-                                          0x08,0x00,
-                                          0x08,0x00,
+                                          0x08,0x00,  
+                                          0x08,0x00,  
+                                          0x08,0x00,  
+                                          0x08,0x00,  
+                                          0xff,0x80,  
+                                          0x08,0x00,  
+                                          0x08,0x00,  
+                                          0x08,0x00,  
                                           0x08,0x00,  /* PLUS 9x9 = 1.0 */
 
                                           0x04,0x00,
@@ -2193,8 +2193,6 @@
 #ifdef OCC7667
       GLsizei w, h, size, j;
 #endif
-
-
       k1 = i / TEL_NO_OF_SIZES;
       k2 = i % TEL_NO_OF_SIZES;
       offset = array[k1][k2].offset;
@@ -2207,9 +2205,14 @@
       glNewList( (GLuint) array[k1][k2].str[0]+markerBase, GL_COMPILE);
 
 #ifdef OCC7667
-      glBitmap( w, h, (float)(array[k1][k2].width) / ( float )2.0,
+
+#if 1
+	  glBitmap( w, h, (float)(array[k1][k2].width) / ( float )2.0,
                       (float)(array[k1][k2].height) / ( float )2.0,
                       ( float )30.0,  ( float )30.0, (const GLubyte *) &raster[offset]);
+#else
+      glBitmap( w, h, (float) (w / 2), (float) (h / 2), 30.0f, 30.0f, (const GLubyte *) &raster[offset]);
+#endif
 
       glPassThrough( GL2PS_MARKER );
       glPassThrough( ( GLfloat ) array[k1][k2].width );
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_subrvis.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_subrvis.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_subrvis.c	2005-03-18 16:17:17.000000000 +0100
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_subrvis.c	2009-10-03 01:04:23.000000000 +0200
@@ -60,17 +60,17 @@
 
 #ifdef WNT
 #define BUC60579        /*GG_240999 Under WNT,resets the ws attributes for each
-//                        created view-manager and not only for the first
+                        created view-manager and not only for the first
 */
 #endif
 
 #define IMP190100	/*GG Reverse the front & back depth cueing planes
-//			position.
+			position.
 */
 
 #define RIC120302	/*GG Use TxglSetWindow instead TxglCreateWindow
-//			when a GLXContext is given
-//			Add call_subr_displayCB function
+			when a GLXContext is given
+			Add call_subr_displayCB function
 */
 
 #define  BUC61044    /* 25/10/01 SAV ; added functionality to control gl depth testing
@@ -735,8 +735,17 @@
 call_subr_close_ws( CALL_DEF_VIEW * aview )
 {
     CMN_KEY_DATA key;
+
+/* PCD 26/06/07 ------ Starts */
 #ifdef OCC1188
     tsm_bg_texture texture;
+#endif
+    /* make sure the proper rendering context is current */
+    TsmGetWSAttri( aview->WsId, WSWindow, &key );
+    TxglWinset( call_thedisplay, (Window) key.ldata );
+
+#ifdef OCC1188
+/* PCD 26/06/07 ------ Ends */
 
     TsmGetWSAttri( aview->WsId, WSBgTexture, &key );
     texture = key.pdata;
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_tXfm.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_tXfm.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_tXfm.c	2008-08-15 15:54:07.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_tXfm.c	2009-10-03 01:04:23.000000000 +0200
@@ -3,24 +3,24 @@
      FONCTION :
      ----------
         File OpenGl_tXfm.c :
- 
+
 
      REMARQUES:
-     ---------- 
-     
-         Dans la methode alloc_new_font() des que l'on depasse 
+     ----------
+
+         Dans la methode alloc_new_font() des que l'on depasse
          (last_font > CACHE_SIZE) les performances s'ecroulent.
-      
+
 
      HISTORIQUE DES MODIFICATIONS   :
      --------------------------------
        xx-xx-xx : xxx ; Creation.
        26-06-96 : FMN ; Correction des textes clippes. On utilise glXUseXFont()
-       27-06-96 : FMN ; Correction hauteur des textes. 
+       27-06-96 : FMN ; Correction hauteur des textes.
        14-02-97 : FMN ; Suppression de MYGLXUSEXFONT
        12-09-97 : CAL ; Protection si tXfmfindfont echoue.
                         modifs dans tXfmfindfont, tXfmsetfont et tXfmprstr
-       02-11-98 : FMN ; PRO12916: Desactivation de la gestion du CharacterExpansionFactor 
+       02-11-98 : FMN ; PRO12916: Desactivation de la gestion du CharacterExpansionFactor
                         qui n'est pas implementee. Ce point sera traite de maniere
                         complete avec l'utilisation d'une librairie specifique
                         de type GLC. Pour le moment il est preferable de le
@@ -89,14 +89,14 @@
 #else
 #define MAX_X11_COORD (1 << 15)
 #endif
-        
+
 #define MAX_GLYPHS_PER_GRAB 512 /* this is big enough for 2^9 glyph character sets */
 
 /*----------------------------------------------------------------------*/
 /*
  * Prototypes fonctions internes
  */
-        
+
 static int getXfontind(float *, float , int );
 static void getXsizefromstr(float *, char **, int );
 static txfmfonthandle alloc_new_font(char *);
@@ -111,77 +111,84 @@
 static txfmfonthandle tXfmfontset[CACHE_SIZE];
 
 static int last_font = 0;
-static FontEntry fontEntry[] = 
+static FontEntry fontEntry[] =
 {
   {"Courier",
    "-adobe-courier-medium-r-normal--*-*-*-*-*-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
+    0},
+  {"Courier-Bold",
+   "-adobe-courier-bold-r-normal--*-*-*-*-*-*-iso8859-1",
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0},
   {"Times-Roman",
    "-adobe-times-medium-r-normal--*-*-*-*-*-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0},
   {"Times-Bold",
    "-adobe-times-bold-r-normal--*-*-*-*-*-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0},
   {"Times-Italic",
    "-adobe-times-medium-i-normal--*-*-*-*-*-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0},
   {"Times-BoldItalic",
    "-adobe-times-bold-i-normal--*-*-*-*-*-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
     0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
         0},
   {"ZapfChancery-MediumItalic",
    "-adobe-itc zapf chancery-medium-i-normal--*-*-*-*-*-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
         0},
   {"Symbol",
    "-adobe-symbol-medium-r-normal--*-*-*-*-*-*-adobe-fontspecific",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
         0},
   {"ZapfDingbats",
    "-adobe-itc zapf dingbats-medium-r-normal--*-*-*-*-*-*-adobe-fontspecific",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0},
   {"Rock",
    "-sgi-rock-medium-r-normal--*-*-*-*-p-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0},
   {"Iris",
    "--iris-medium-r-normal--*-*-*-*-m-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0}
 };
 
@@ -196,16 +203,16 @@
 {
     int dir = 0, asc = 0, des = 0;
     XCharStruct mes;
-    
+
     if (current_fonthandle != NULL && current_fonthandle->fontInfo != NULL && str != NULL )
     {
        XTextExtents(current_fonthandle->fontInfo, str, strlen(str), &dir, &asc, &des, &mes);
 
 #ifdef TRACE
-        printf("XTextExtents::asc = %d des = %d width = %d \n", asc, des, mes.width); 
+        printf("XTextExtents::asc = %d des = %d width = %d \n", asc, des, mes.width);
 #endif
         *Ascent = current_fonthandle->fontInfo->ascent;
-        *Descent = current_fonthandle->fontInfo->descent; 
+        *Descent = current_fonthandle->fontInfo->descent;
         *Width = mes.width;
     }
     else
@@ -234,10 +241,10 @@
     req_size = bestfont_size*1.36F; /* 98/72 dpi*/
 #endif
 
-    /* 
-     * Verifie que la (fonte,taille) n'ont pas deja ete traite 
+    /*
+     * Verifie que la (fonte,taille) n'ont pas deja ete traite
      */
-     
+
     for (i=0, a=0; i < last_font && !found_font; i++) {
         if(strcmp(tXfmfontset[i]->fontname, fontname) == 0) {
             if((tXfmfontset[i]->charsize) == req_size) {
@@ -254,10 +261,10 @@
     }
     if (found_font) return (current_fonthandle);
 
-    /* 
+    /*
      * Recherche dans les fontes disponibles: fontEntry
      */
-     
+
     for (i=0 ; i< NUM_FONT_ENTRIES ; i++) {
         if(  strcmp(fontname, fontEntry[i].name) == 0 ) {
             found_entry = 1;
@@ -296,7 +303,7 @@
 	  break;
 	}
     }
-    
+
     if (found_font) return (current_fonthandle);
 
     fonthandle = alloc_new_font(fontname);
@@ -328,7 +335,7 @@
 
     fonthandle = current_fonthandle;
 
-    isNeedUpdate = 0; /* = 1 if doesn't exist font or 
+    isNeedUpdate = 0; /* = 1 if doesn't exist font or
                            if needs for regenerate font ( Number of LastFont is exeeds  maxFontSize,
                            i.e.fonthandle->dirty = 1 ) */
     if ( fonthandle->listBase ) {
@@ -337,14 +344,14 @@
 	  isNeedUpdate = 0;
 	  pBase = fonthandle->listBase; /*OCC6247*/
 	  /*return(fonthandle->listBase);*/ /*OCC6247*/
-        } 
+        }
         else  /* dirty , reutilise fonthandle */
-        {  
+        {
 	    isNeedUpdate = 1;
             pBase = fonthandle->listBase;
         }
-    } 
-    else 
+    }
+    else
     {
         isNeedUpdate = 1; /* Nouvelle fonte */
         pBase = glGenLists(NUM_CHAR_FONT);
@@ -371,10 +378,10 @@
     fonthandle->listBase = pBase;
     fonthandle->dirty = 0;
     fonthandle->fontInfo = fontInfo;
-    
+
     fonthandle->xscale = txfmxscale;
     fonthandle->yscale = txfmyscale;
-    
+
 /*    XFreeFont( fonthandle->dpy, fontInfo); */
     return(pBase);
 }
@@ -398,7 +405,7 @@
 
 /* OCC7456 abd 14.12.2004 Text alignment attributes  */
 
- if (Base == 0) 
+ if (Base == 0)
    return;
 
 /* OCC7456 abd 14.12.2004 Text alignment attributes  */
@@ -455,9 +462,9 @@
     glGetIntegerv( GL_VIEWPORT, (GLint*)viewport );
 
     gluProject( x, y, z, (GLdouble*)modelMatrix, (GLdouble*)projMatrix, (GLint*)viewport, &xw, &yw, &zw );
-    gluUnProject( xw - xdis, yw - ydis, zw, 
+    gluUnProject( xw - xdis, yw - ydis, zw,
                   (GLdouble*)modelMatrix, (GLdouble*)projMatrix, (GLint*)viewport,
-                  &xv, &yv, &zv );    
+                  &xv, &yv, &zv );
     glRasterPos3d(xv, yv, zv);
 
 /*OCC7456 abd 14.12.2004 Text alignment attributes  */
@@ -466,11 +473,11 @@
     /* SAMTECH modif -- Geoff Levner 19/7/2007 -- added render mode test */
     glGetIntegerv(GL_RENDER_MODE, &renderMode);
     if (renderMode == GL_FEEDBACK) {
-      exportText( (char*) str, current_fontname,
-		  current_fonthandle->charsize * call_tox_getpitchsize(),
-		  x, y, z, GL_FALSE );
-      glRasterPos3f( x, y, z );
-    }
+    exportText((char*) str, current_fontname,
+                current_fonthandle->charsize * call_tox_getpitchsize(),
+                x, y, z, GL_FALSE );
+    glRasterPos3f( x, y, z );
+  }
 #endif
 
     glPushAttrib(GL_LIST_BIT);
@@ -600,7 +607,7 @@
 #endif
 
 typedef struct _font_handle {
-        
+
                     GLuint  listBase;
                     HGLRC   curRC;
                     float   xScale;
@@ -632,7 +639,7 @@
                     float       charRatios[MAX_NB_CHARS];
                } TM_FONT_HANDLE;
 #endif
-                
+
 typedef struct _font_entry {
 
                     char*       name;
@@ -674,9 +681,9 @@
 static int useTexFont = 0;
 static int curTexFont = -1;
 TEL_POINT  char_offsets[4] =
-            { { 0., 0., 0. }, 
-              { 0., 0., 0. }, 
-              { 0., 0., 0. }, 
+            { { 0., 0., 0. },
+              { 0., 0., 0. },
+              { 0., 0., 0. },
               { 0., 0., 0. } };
 
 #endif
@@ -695,13 +702,13 @@
 void sizeString(char *str, GLint *Width, GLint *Ascent, GLint *Descent)
 {
 /*    int       dir, asc, des;*/
-    
+
     if (curFont != -1)
     {
-        *Ascent = (int)fontEntry[ curFont ].fs[ curSize ].lHeight 
+        *Ascent = (int)fontEntry[ curFont ].fs[ curSize ].lHeight
                     - (int)fontEntry[ curFont ].fs[ curSize ].lInternalLeading
                 - (int)fontEntry[ curFont ].fs[ curSize ].lDescent;
-        *Descent = (int)fontEntry[ curFont ].fs[ curSize ].lDescent; 
+        *Descent = (int)fontEntry[ curFont ].fs[ curSize ].lDescent;
         *Width = fontEntry[ curFont ].fs[ curSize ].lWidth * strlen(str);
     }
     else
@@ -711,7 +718,7 @@
         *Width = 0;
     }
 #ifdef TRACE
-        printf("sizeString::asc = %d des = %d width = %d \n", *Ascent, *Descent, *Width); 
+        printf("sizeString::asc = %d des = %d width = %d \n", *Ascent, *Descent, *Width);
 #endif
 }
 
@@ -720,12 +727,18 @@
 
 /* loadTexFont(): Prepares a square texture containing glyphs for the given font */
 
-/* Current limitations: 
+/* Current limitations:
 - texture of fixed size 256 x 256 pixels is used,
 - each glyph occupies a 16 x 16 square in the texture,
 - fixed font height (16) is used for texture creation */
+
+
+
+
 static GLint loadTexFont(char* fontName, TM_FONT_HANDLE* fontHandle)
 {
+	
+
   GLint tex_id = -1;
   HFONT font;
   HDC   hMemDC, hDC = NULL;
@@ -734,13 +747,15 @@
   BITMAPINFO bi;
   HBITMAP hBmp, hOldBmp;
   const int spacing = 2;             /* spacing between characters in a string */
-  GLubyte fontBits [256 * 256 * 3];  /* font bitmap array: RGB */
-  GLubyte ifontBits[256 * 256 * 2];  /* texture array: luminance and alpha */
+  /* DFA 2007-04-17 make these static to prevent stack overflow.  */
+  static GLubyte fontBits [256 * 256 * 3]; /* font bitmap array: RGB */
+  static GLubyte ifontBits[256 * 256 * 2]; /* texture array: luminance and alpha */
   int charWidths[MAX_NB_CHARS];
 
   if ( !fontHandle )
     return tex_id;
 
+ 
   memset(fontHandle, 0, sizeof(TM_FONT_HANDLE));
 
   fontHandle->curRC   = wglGetCurrentContext();
@@ -766,7 +781,7 @@
   hDC       = wglGetCurrentDC();
   hMemDC    = CreateCompatibleDC(hDC);
   hBmp      = CreateCompatibleBitmap(hDC, fontHandle->texSize, fontHandle->texSize);
-  hOldBmp   = (HBITMAP)SelectObject(hMemDC, hBmp);        
+  hOldBmp   = (HBITMAP)SelectObject(hMemDC, hBmp);
   SelectObject(hMemDC, font);
   SetTextColor(hMemDC, RGB(255, 255, 255));
   SetBkColor  (hMemDC, RGB(0, 0, 0));
@@ -791,7 +806,7 @@
   bi.bmiHeader.biHeight      = -fontHandle->texSize;
   bi.bmiHeader.biWidth       = fontHandle->texSize;
   bi.bmiHeader.biCompression = BI_RGB;
-  SelectObject(hMemDC, hOldBmp);        
+  SelectObject(hMemDC, hOldBmp);
   num = GetDIBits(hMemDC, hBmp, 0, fontHandle->texSize, fontBits, &bi, DIB_RGB_COLORS);
 
   /* prepare an array of alpha and luminance values */
@@ -803,38 +818,51 @@
     }
 
   /* create the font texture */
+
+  /*BUG OCC13611 - remember parameters of texture mapping*/
+  glPushAttrib( GL_ENABLE_BIT | GL_TEXTURE_BIT );
+
   glGenTextures(1, &tex_id);
   glBindTexture(GL_TEXTURE_2D, tex_id);
   glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, 
+  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
     GL_REPEAT);
-  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, 
+  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
     GL_NEAREST);
-  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, 
+  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
     GL_NEAREST);
 
-  glTexImage2D(GL_TEXTURE_2D, 
-               0, 
+  glTexImage2D(GL_TEXTURE_2D,
+               0,
                GL_INTENSITY,
-               fontHandle->texSize, 
-               fontHandle->texSize, 
-               0, 
-               GL_LUMINANCE_ALPHA, 
-               GL_UNSIGNED_BYTE, 
+               fontHandle->texSize,
+               fontHandle->texSize,
+               0,
+               GL_LUMINANCE_ALPHA,
+               GL_UNSIGNED_BYTE,
                ifontBits);
 
   fontHandle->textureId = tex_id;
 
+  glPopAttrib();
+   
+  /*
+   * free windows resources
+   */
+  DeleteObject(font);
+  DeleteObject(hBmp);
+  DeleteDC(hMemDC);
+
   return tex_id;
 }
 
 
-/* texPrint(): displays a string using texture <tex_id>, 
+/* texPrint(): displays a string using texture <tex_id>,
 <offsets> is used to convert quickly 16-pixel offset in viewport co-ordinates
 to offsets in world co-ordinates */
 
-/* Current limitations: 
+/* Current limitations:
 - texture of fixed size 256 x 256 pixels is used */
 static void texPrint( Tchar* data, TM_FONT_HANDLE* fontHandle, TEL_POINT* offsets )
 {
@@ -862,11 +890,11 @@
 
    glBindTexture(GL_TEXTURE_2D, fontHandle->textureId);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-   
+
    l = strlen(data);
 
    glBegin(GL_QUADS);
-   
+
    for (i = 0; i < l; i++)
    {
      code = data[i];
@@ -880,7 +908,7 @@
      tx1 = b / divisor;
      ty0 = c / divisor;
      ty1 = d / divisor;
-     
+
      glTexCoord2f(tx0, ty0);
      glVertex3f(x, y, z);
      glTexCoord2f(tx1, ty0);
@@ -906,15 +934,17 @@
 void WNTUseTexMappedFont( int flag )
 {
   int i;
-
   if (flag && !useTexFont && curFont != -1)
   {
     FONT_ENTRY* fe = &fontEntry[curFont];
     HGLRC curRC = wglGetCurrentContext();
 
     for (i = 0; i < MAX_FONT_TEXTURES; i++ )
-    {
-      if (fe->tfh[i].curRC == curRC)
+    {                                        		
+		/*BUG OCC15715*/
+		/* Looking for an existing texture for the current RC or the first empty item in
+		the texture cache (with curRC == 0) */
+		if (fe->tfh[i].curRC == curRC ||fe->tfh[i].curRC == 0)  		
         break;
     }
 
@@ -924,10 +954,14 @@
       glDeleteTextures(1, &(fe->tfh[i].textureId));
     }
 
-    if ( fe->tfh[i].curRC != curRC || fe->tfh[i].textureId == 0)
-      loadTexFont( fe->lfFaceName, &(fe->tfh[i]) );
+	if ( fe->tfh[i].curRC !=curRC || fe->tfh[i].textureId == 0){
+		loadTexFont( fe->lfFaceName, &(fe->tfh[i]) );
+	}
+
+
+    
+	curTexFont = i;
 
-    curTexFont = i;
   }
 
   useTexFont = flag;
@@ -958,14 +992,14 @@
 #ifdef OCC2934
     texLoadNeeded = (useTexFont && curFont != i);
 #endif
- 
+
   fs      = &( fontEntry[ i ].fs[ 0 ] );
   curFont = i;
 
   for ( i = 0; i < MAX_FONT_SIZES; ++i ) {
-  
+
    if ( fs[ i ].charSize == 0 ) {
-   
+
         curSize = i;
 
         loadNewFont (  &( fs[ i ].fh[ 0 ] ), bestSize, TRUE  );
@@ -973,36 +1007,36 @@
         break;
 
    } else if ( fs[ i ].charSize == bestSize ) {
-   
+
         curSize = i;
         updateSizeUsage ();
-        
-    break;   
-   
+
+    break;
+
    }  /* end if */
-   
+
   }  /* end for */
 
   if ( i == MAX_FONT_SIZES ) {
-  
+
    min_val = UINT_MAX;
    min_idx = 0;
-   
+
    for ( i = 0; i < MAX_FONT_SIZES; ++i )
-   
+
     if ( fs[ i ].useCount < min_val ) {
-    
+
      min_val = fs -> useCount;
-     min_idx = i;    
-    
+     min_idx = i;
+
     }  /* end if */
 
    curSize = min_idx;
 
    loadNewFont (  &( fs[ min_idx ].fh[ 0 ] ), bestSize, TRUE  );
-  
+
   }  /* end if */
- 
+
  }  /* end else */
 
 #ifdef OCC2934
@@ -1012,8 +1046,11 @@
     HGLRC curRC = wglGetCurrentContext();
 
     for (i = 0; i < MAX_FONT_TEXTURES; i++ )
-    {
-      if (fe->tfh[i].curRC == curRC)
+    {            	
+		/*BUG OCC15715*/
+		/* Looking for an existing texture for the current RC or the first empty item in
+		the texture cache (with curRC == 0) */
+		if (fe->tfh[i].curRC == curRC ||fe->tfh[i].curRC == 0)      		
         break;
     }
 
@@ -1023,8 +1060,11 @@
       glDeleteTextures(1, &(fe->tfh[i].textureId));
     }
 
-    if ( fe->tfh[i].curRC != curRC || fe->tfh[i].textureId == 0)
-      loadTexFont( fe->lfFaceName, &(fe->tfh[i]) );
+
+	if ( fe->tfh[i].curRC != curRC || fe->tfh[i].textureId == 0){
+		loadTexFont( fe->lfFaceName, &(fe->tfh[i]) );
+
+	}
 
     curTexFont = i;
  }
@@ -1054,13 +1094,13 @@
         fh[ i ].yScale == yScale &&
             fh[ i ].curRC  == hGLRC
    ) {
-  
+
     retVal = fh[ i ].listBase;
         curScale = i;
         updateScaleUsage ();
-   
-    break;  
-  
+
+    break;
+
    } else if ( fh[ i ].xScale == 0.0F && fh[ i ].yScale == 0.0F ) {
 
     newScale = TRUE;
@@ -1069,7 +1109,7 @@
    }  /* end if */
 
   if ( !retVal ) {
- 
+
    if ( newScale ) {
 
     fh[ i ].xScale = xScale;
@@ -1080,19 +1120,19 @@
     loadNewFont ( &fh[ i ], 0.0F, FALSE );
 
     retVal = fh[ i ].listBase;
-  
+
    } else {
-  
+
     min_val = UINT_MAX;
     min_idx = 0;
-   
-    for ( i = 0; i < MAX_FONT_SCALES; ++i )   
-                                                                                         
-     if ( fh[ i ].useCount < min_val ) {     
-    
+
+    for ( i = 0; i < MAX_FONT_SCALES; ++i )
+
+     if ( fh[ i ].useCount < min_val ) {
+
       min_val = fh -> useCount;
-      min_idx = i;    
-    
+      min_idx = i;
+
      }  /* end if */
 
     fh[ min_idx ].xScale = xScale;
@@ -1101,7 +1141,7 @@
         curScale = i;
 
     loadNewFont ( &fh[ min_idx ], 0.0F, FALSE );
-         
+
     retVal = fh[ min_idx ].listBase;
 
    }  /* end else ( newScale . . . ) */
@@ -1188,10 +1228,10 @@
  /* SAMTECH modif -- Geoff Levner 19/7/2007 -- added render mode test */
  glGetIntegerv(GL_RENDER_MODE, &renderMode);
  if (renderMode == GL_FEEDBACK) {
-   exportText( str, fontEntry[curFont].name,
-	       ( GLfloat )fontEntry[ curFont ].fs[ curSize ].lHeight,
-	       x, y, z, is2d!=0 );
- }
+  exportText( str, fontEntry[curFont].name,
+              ( GLfloat )fontEntry[ curFont ].fs[ curSize ].lHeight,
+              x, y, z, is2d!=0 );
+}
 #endif
 
 #ifdef OCC2934
@@ -1205,7 +1245,7 @@
    glPushMatrix();
 
    glTranslatef(x, y, z);
-   
+
    texPrint( str, &(fontEntry[curFont].tfh[curTexFont]), char_offsets );
 
    /* Restore previous matrices */
@@ -1227,12 +1267,12 @@
     glGetIntegerv( GL_VIEWPORT, (GLint*)viewport );
 
     gluProject( x, y, z, (GLdouble*)modelMatrix, (GLdouble*)projMatrix, (GLint*)viewport, &xw, &yw, &zw );
-    gluUnProject( xw - xdis, yw - ydis, zw, 
+    gluUnProject( xw - xdis, yw - ydis, zw,
                   (GLdouble*)modelMatrix, (GLdouble*)projMatrix, (GLint*)viewport,
-                  &xv, &yv, &zv );    
+                  &xv, &yv, &zv );
     glRasterPos3d(xv, yv, zv);
 /*OCC7456 abd 14.12.2004 Text alingnment attributes  */
-    //glRasterPos3f(x, y, z);
+    /*glRasterPos3f(x, y, z); */
  }
 #endif
 
@@ -1262,10 +1302,10 @@
  glPixelTransferi ( GL_MAP_COLOR, GL_TRUE );
 
  glCallLists (  lstrlen ( str ), GL_UNSIGNED_BYTE, str );
- 
- /*san -- 12/11/2004 -- OCC7190 Texture-mapped fonts don't work, 
+
+ /*san -- 12/11/2004 -- OCC7190 Texture-mapped fonts don't work,
    as soon as any old-style (bitmap) text is displayed */
- glPixelTransferi(GL_MAP_COLOR, GL_FALSE); 
+ glPixelTransferi(GL_MAP_COLOR, GL_FALSE);
 
  glDisable ( GL_ALPHA_TEST );
 
@@ -1287,18 +1327,18 @@
  ZeroMemory (  ( PVOID )&lf, sizeof ( LOGFONT )  );
 
  if ( newSize ) {
- 
+
   fhTemp = fontEntry[ curFont ].fs[ curSize ].fh;
 
   for ( i = 0; i < MAX_FONT_SCALES; ++i )
-  
+
    if ( fhTemp[ i ].listBase ) {
 
     glDeleteLists (fhTemp[ i ].listBase, fontEntry[ curFont ].fs[ curSize ].listRange);
     ZeroMemory (  ( PVOID )&fhTemp[ i ], sizeof ( FONT_HANDLE )  );
 
    } else
-   
+
     break;
 
   fh -> xScale   = 1.0F;
@@ -1333,14 +1373,14 @@
   fontEntry[ curFont ].fs[ curSize ].lInternalLeading  = tm.tmInternalLeading;
   fontEntry[ curFont ].fs[ curSize ].lDescent = tm.tmDescent;
 
- } 
- else 
+ }
+ else
  {  /* new scale */
- 
+
   if ( fh -> listBase )
 
    glDeleteLists (fh -> listBase, fontEntry[ curFont ].fs[ curSize ].listRange);
-  
+
   lf.lfHeight  = ( LONG )( fontEntry[ curFont ].fs[ curSize ].lHeight * fh -> yScale );
   lf.lfWidth   = ( LONG )( fontEntry[ curFont ].fs[ curSize ].lWidth  * fh -> xScale );
   lf.lfCharSet = ANSI_CHARSET;
@@ -1359,7 +1399,7 @@
   DeleteObject ( hFont );
 
   fh -> curRC = wglGetCurrentContext ();
- 
+
  }  /* end else ( newSize . . . ) */
 
 }  /* end loadNewFont */
@@ -1372,8 +1412,8 @@
 
  if ( fontEntry[ curFont ].fs[ curSize ].useCount == UINT_MAX )
   for ( i = 0; i < MAX_FONT_SIZES; ++i )
-   fontEntry[ curFont ].fs[ i ].useCount >>= 1;   
- 
+   fontEntry[ curFont ].fs[ i ].useCount >>= 1;
+
  ++fontEntry[ curFont ].fs[ curSize ].useCount;
 
 }  /* end updateSizeUsage */
@@ -1386,7 +1426,7 @@
 
  if ( fontEntry[ curFont ].fs[ curSize ].fh[ curScale ].useCount == UINT_MAX )
   for ( i = 0; i < MAX_FONT_SCALES; ++i )
-        fontEntry[ curFont ].fs[ curSize ].fh[ i ].useCount >>= 1;   
+        fontEntry[ curFont ].fs[ curSize ].fh[ i ].useCount >>= 1;
 
  ++fontEntry[ curFont ].fs[ curSize ].fh[ curScale ].useCount;
 
@@ -1424,7 +1464,7 @@
     glRasterPos2f( x, y );
   else
     glRasterPos3f( x, y, z );
-  
+
   glBitmap( 1, 1, 0, 0, 0, 0, &zero );
 
   glPassThrough( height );
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_telem_util.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_telem_util.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_telem_util.c	2008-07-25 16:03:54.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_telem_util.c	2009-10-03 01:04:22.000000000 +0200
@@ -3,18 +3,18 @@
      FONCTION :
      ----------
         File OpenGl_telem_util :
- 
+
 
      REMARQUES:
-     ---------- 
-      
+     ----------
+
 
      HISTORIQUE DES MODIFICATIONS   :
      --------------------------------
        xx-xx-xx : xxx ; Creation.
        07-02-96 : FMN ; - Ajout trace
 			- Suppression code inutile
-       08-03-96 : FMN ; - Ajout include manquant 
+       08-03-96 : FMN ; - Ajout include manquant
        01-04-96 : CAL ; Integration MINSK portage WNT
        15-04-96 : CAL ; Integration travail PIXMAP de Jim ROTH
        22-04-96 : FMN ; Ajout TelReadImage TelDrawImage
@@ -35,7 +35,7 @@
        18-07-97 : FMN ; Utilisation de la toolkit sur les lights
        07-10-97 : FMN ; Simplification WNT + correction Transient
        05-12-97 : FMN ; PRO11168: Suppression TglActiveWs pour project/unproject
-       23-12-97 : FMN ; Suppression TelSetFrontFaceAttri et TelSetBackFaceAttri 
+       23-12-97 : FMN ; Suppression TelSetFrontFaceAttri et TelSetBackFaceAttri
        30-12-97 : FMN ; CTS18312: Correction back material
        04-05-98 : CAL ; Contournement bug SGI octane bavure de pixels (PRO12899)
        30-09-98 : CAL ; Optimisation pour eviter de charger inutilement
@@ -49,8 +49,9 @@
 ************************************************************************/
 
 #define IMP190100	/*GG To avoid too many REDRAW in immediat mode,
-//			Add TelMakeFrontAndBackBufCurrent() function
+			Add TelMakeFrontAndBackBufCurrent() function
 */
+#define QTOCC_PATCH
 
 /*----------------------------------------------------------------------*/
 /*
@@ -104,7 +105,7 @@
 /*
  * Variables statiques
  */
- 
+
 static Tint call_back_buffer_restored = TOff;
 
 #ifndef WNT
@@ -233,10 +234,10 @@
 TelRemdupnames(Tint *ls, Tint num )
 {
     register  Tint  *ap, *bp, n;
-    
+
     if( num < 2 )
     return num;
-    
+
     ap = bp = ls+1;
     n = num-1;
     while( n-- )
@@ -246,7 +247,7 @@
     else
     bp++;
     }
-    
+
     return ap-ls;
 }
 
@@ -255,9 +256,9 @@
 #define GPRECIS 0.000001
 Tint TelGetPolygonNormal(tel_point pnts, Tint* indexs, Tint npnt, Tfloat *norm ) {
     Tint status=0;
-   
+
     norm[0] = norm[1] = norm[2] = 0.;
-    if( npnt > 2 ) { 
+    if( npnt > 2 ) {
       Tfloat a[3], b[3], c[3];
       Tint i,j,i0,ii=0,jj;
 
@@ -314,7 +315,7 @@
 void
 TelGetNormal(Tfloat *data1, Tfloat *data2, Tfloat *data3, Tfloat *norm ) {
     Tfloat a[3], b[3];
-    
+
     vecsub( a, data2, data1 );
     vecsub( b, data3, data2 );
     veccrs( norm, a, b );
@@ -326,12 +327,12 @@
 TelIsBackFace(Tmatrix3 n, Tfloat *nrm )
 {
     Tfloat    r[4], m[4];
-    
+
     veccpy(m,nrm);
     m[3] = ( float )1.0;
-    
+
     TelTranpt3( r, m, n );
-    
+
     return r[2] < 0.0;
 }
 
@@ -384,7 +385,7 @@
 {
     register  long  i, j;
     Tfloat    sum;
-    
+
     for( i = 0; i < 4; i++ )
     {
     for( j = 0, sum = ( float )0.0; j < 4; j++ )
@@ -428,15 +429,15 @@
 	}
 	else
 	{
-	    glDrawBuffer(GL_FRONT_AND_BACK);
-	    glClearColor(bgcolr, bgcolg, bgcolb, ( float )1.0);
-	    glClear(GL_COLOR_BUFFER_BIT);
+		/* QTOCC_PATCH by PCD: the frame buffer should not be cleared here
+		   to avoid flicker. It is cleared properly in TelClearViews() 
+		   called by call_func_redraw_all_structs_begin() */
 	    glDrawBuffer(GL_BACK);
 	}
 #else
-	glDrawBuffer(GL_FRONT_AND_BACK);
-	glClearColor(bgcolr, bgcolg, bgcolb, ( float )1.0);
-	glClear(GL_COLOR_BUFFER_BIT);
+	/* QTOCC_PATCH by PCD: the frame buffer should not be cleared here
+	   to avoid flicker. It is cleared properly in TelClearViews() 
+	   called by call_func_redraw_all_structs_begin() */
 	glDrawBuffer(GL_BACK);
 #endif /* WNT */
     }
@@ -446,6 +447,7 @@
 	glClear(GL_COLOR_BUFFER_BIT);
     }
     return;
+
 }
 
 
@@ -455,7 +457,7 @@
 #ifndef WNT
 
     CMN_KEY_DATA data;
-   
+
     if (TelTestPixmapDB())
     {
         glFlush();
@@ -468,9 +470,9 @@
 	TsmGetWSAttri( ws, WSWindow, &data );
         glXSwapBuffers ( call_thedisplay, data.ldata );
     }
- 
+
 #else
-    
+
     SwapBuffers ( wglGetCurrentDC () );
     TelFlush(0);
 
@@ -545,7 +547,7 @@
 	glLoadIdentity ();
 
 	TelDisable (ws);
-	if (flag) 
+	if (flag)
 	{
 	    /*
 	     * calcul de la projection de la boite
@@ -565,7 +567,7 @@
 	    &&  (TelProjectionRaster (ws, xm, ym, ZM, &xr[4], &yr[4]) == TSuccess)
 	    &&  (TelProjectionRaster (ws, xm, YM, ZM, &xr[5], &yr[5]) == TSuccess)
 	    &&  (TelProjectionRaster (ws, XM, YM, ZM, &xr[6], &yr[6]) == TSuccess)
-	    &&  (TelProjectionRaster (ws, XM, ym, ZM, &xr[7], &yr[7]) == TSuccess)) 
+	    &&  (TelProjectionRaster (ws, XM, ym, ZM, &xr[7], &yr[7]) == TSuccess))
 	    {
 		xmr = ymr = (float ) shortreallast ();
 		XMR = YMR = (float ) shortrealfirst ();
@@ -581,7 +583,7 @@
 		/* pour eviter les bavures de pixels ! */
 		xmr--;ymr--;
 		XMR++;YMR++;
-    
+
 		/*
 		 * Ajout CAL : 10/05/96
 		 * Si les MinMax viennent d'un ensemble de markers
@@ -594,7 +596,7 @@
 		 */
 		xmr -= CALL_DEF_DELTA; ymr -= CALL_DEF_DELTA;
 		XMR += CALL_DEF_DELTA; YMR += CALL_DEF_DELTA;
-    
+
 		/*
 		 * Le rectangle projete peut-etre clippe
 		 */
@@ -619,7 +621,7 @@
 		if (ymr < 0) { height = (GLsizei) (YMR+1); ymr = 0; }
 		if (XMR > w) { width  = (GLsizei) (w-xmr+1); }
 		if (YMR > h) { height = (GLsizei) (h-ymr+1); }
-    
+
 		/* cas ou les 2 coins sont en dehors de la fenetre */
 		if (XMR < 0) { xmr = 0; width = height = 1; }
 		if (YMR < 0) { ymr = 0; width = height = 1; }
@@ -639,7 +641,7 @@
 		glCopyPixels ((GLint) xmr, (GLint) ymr, width, height, GL_COLOR);
 		/* TelFlush (1); */
 	    }
-	    else 
+	    else
 	    {
 		glDrawBuffer (to);
 		/* TelClearViews (ws); */
@@ -650,7 +652,7 @@
 		/* TelFlush (1); */
 	    }
 	}
-	else 
+	else
 	{
 	    glDrawBuffer (to);
 	    /* TelClearViews (ws); */
@@ -666,7 +668,7 @@
 	glPopMatrix ();
 	glMatrixMode (GL_MODELVIEW);
 	glPopMatrix ();
-    
+
 	glDrawBuffer (GL_BACK);
 	return;
 }
@@ -694,17 +696,17 @@
 	gluOrtho2D ((GLdouble) 0., (GLdouble) w, 0., (GLdouble) h);
 	glMatrixMode (GL_MODELVIEW);
 	glLoadIdentity ();
-	
-	glReadBuffer(from); 
-	
+
+	glReadBuffer(from);
+
 	glRasterPos2i (posx, posy);
 	TelDisable (ws);
 	glReadPixels (posx, posy, width, height, GL_RGBA, GL_UNSIGNED_BYTE, image);
 	TelEnable (ws);
-    
-	glReadBuffer(GL_BACK);        
+
+	glReadBuffer(GL_BACK);
     }
-    
+
     return;
 }
 
@@ -731,16 +733,16 @@
 	gluOrtho2D ((GLdouble) 0., (GLdouble) w, 0., (GLdouble) h);
 	glMatrixMode (GL_MODELVIEW);
 	glLoadIdentity ();
-	
+
 	glDrawBuffer(to);
-	
+
 	glRasterPos2i (posx, posy);
 	TelDisable (ws);
 	glDrawPixels (width, height, GL_RGBA, GL_UNSIGNED_BYTE, image);
 	TelEnable (ws);
 
-	glDrawBuffer(GL_BACK);     
-    }	    
+	glDrawBuffer(GL_BACK);
+    }
     return;
 }
 
@@ -769,13 +771,13 @@
 	gluOrtho2D ((GLdouble) 0., (GLdouble) w, 0., (GLdouble) h);
 	glMatrixMode (GL_MODELVIEW);
 	glLoadIdentity ();
-	
+
 	glRasterPos2i (posx, posy);
 	TelDisable (ws);
 	glReadPixels (posx, posy, width, height, GL_DEPTH_COMPONENT, GL_FLOAT, depths);
 	TelEnable (ws);
     }
-    
+
     return;
 }
 
@@ -811,7 +813,7 @@
     glDisable(GL_DEPTH_TEST);
     glDisable(GL_FOG);
     LightOff();
-    
+
     glDisable(GL_LOGIC_OP);
     glDisable(GL_STENCIL_TEST);
     glDisable(GL_TEXTURE_1D);
@@ -825,7 +827,7 @@
     glPixelTransferi(GL_BLUE_BIAS, 0);
     glPixelTransferi(GL_ALPHA_SCALE, 1);
     glPixelTransferi(GL_ALPHA_BIAS, 0);
-    
+
     /*
      * Disable extensions that could slow down glDrawPixels.
      * (Actually, you should check for the presence of the proper
@@ -859,15 +861,15 @@
     CMN_KEY_DATA key;
     Tint vid;          /* View index */
     TEL_VIEW_REP vrep; /* View definition */
-    
+
     GLint status;
-    
+
     int i, j, k;
     GLdouble objx, objy, objz;
     GLdouble modelMatrix[16], projMatrix[16];
     GLint viewport[4];
     GLdouble winx, winy, winz;
-    
+
     vid = ws;
 
     if (TelGetViewRepresentation (ws, vid, &vrep) != TSuccess)
@@ -908,7 +910,7 @@
 	*yr = ( Tfloat )winy;
 	return TSuccess;
     }
-    else 
+    else
     {
 	*xr = 0.0F;
 	*yr = 0.0F;
@@ -924,7 +926,7 @@
     CMN_KEY_DATA key;
     Tint vid;          /* View index */
     TEL_VIEW_REP vrep; /* View definition */
-    
+
     int i, j, k;
     GLdouble objx, objy, objz;
     GLdouble modelMatrix[16], projMatrix[16];
@@ -965,7 +967,7 @@
 
     status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
 	    &objx, &objy, &objz);
-    
+
     if (status == GL_TRUE) {
 	    *x = ( Tfloat )objx;
 	    *y = ( Tfloat )objy;
@@ -991,7 +993,7 @@
     CMN_KEY_DATA key;
     Tint vid;          /* View index */
     TEL_VIEW_REP vrep; /* View definition */
-    
+
     int i, j, k;
     GLdouble objx, objy, objz;
     GLdouble objx1, objy1, objz1;
@@ -1033,7 +1035,7 @@
 
     status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
 	    &objx, &objy, &objz);
-    
+
     if (status == GL_TRUE) {
 	    *x = ( Tfloat )objx;
 	    *y = ( Tfloat )objy;
@@ -1042,7 +1044,7 @@
       winz = ( GLdouble ) -10.0;
       status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
 	      &objx1, &objy1, &objz1);
-    
+
       if (status == GL_TRUE) {
         *dx = ( Tfloat )(objx-objx1);
 	*dy = ( Tfloat )(objy-objy1);
@@ -1075,7 +1077,7 @@
 TelFlush(Tint wait)
 {
     if (wait)
-    {    
+    {
 #ifdef TRACE
 	printf("OPENGL: TelFlush: glFinish \n");
 #endif
@@ -1096,21 +1098,21 @@
 TelIsBackFacePerspective(Tmatrix3 n, Tfloat *p1, Tfloat *p2, Tfloat *p3 )
 {
     Tfloat    r1[4], r2[4], r3[4], m[4], norm[4];
-    
+
     veccpy( m, p1 );
     m[3] = ( float )1.0;
     TelTranpt3( r1, m, n );
     r1[0] /= r1[3];
     r1[1] /= r1[3];
     r1[2] /= r1[3];
-    
+
     veccpy( m, p2 );
     m[3] = ( float )1.0;
     TelTranpt3( r2, m, n );
     r2[0] /= r2[3];
     r2[1] /= r2[3];
     r2[2] /= r2[3];
-    
+
     veccpy( m, p3 );
     m[3] = ( float )1.0;
     TelTranpt3( r3, m, n );
@@ -1118,7 +1120,7 @@
     r3[1] /= r3[3];
     r3[2] /= r3[3];
     TelGetNormal( r1, r2, r3, norm );
-    
+
     return norm[2] < 0.0;
 }
 
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_inquireplane.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_togl_inquireplane.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_inquireplane.c	2001-09-21 09:57:49.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_togl_inquireplane.c	2009-10-03 01:04:23.000000000 +0200
@@ -1,7 +1,10 @@
 #define GER61454	/*GG 14-09-99 Activates the model clipping planes
-// GG 110800	UNDER LINUX and MESA 3.2, nothing can be done until
-//		gl context is open first.
+ GG 110800	UNDER LINUX and MESA 3.2, nothing can be done until
+		gl context is open first.
 */
+#ifdef DEBUG
+#include <stdio.h>
+#endif
 
 #include <OpenGl_tgl_all.h>
 #include <OpenGl_tgl.h>
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_redraw.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_togl_redraw.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_redraw.c	2008-07-04 17:36:17.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_togl_redraw.c	2009-10-03 01:04:22.000000000 +0200
@@ -24,19 +24,21 @@
        02.01.100 : JR : = 0 for Integer and = NULL for pointers
        02.02.100   "    #include <GL/glu.h> for declaration of gluErrorString
        07-03-00 : GG : G004 use the already created pixmap.
-                        Enable two side lighting before redrawing in pixmap.
+		             Enable two side lighting before redrawing in pixmap.
 
 ************************************************************************/
 
-#define G004    /* VKH 15-11-99 redrawing view to a large pixmap
+#define G004	/* VKH 15-11-99 redrawing view to a large pixmap
 */
 
-#define IMP100701       /* GG Enable to display the view in
-                        a pixamp with the required depth.
+#define IMP100701	/*  GG Enable to display the view in
+			      a pixamp with the required depth.
 */
 
-#define RIC120302       /* GG Enable to use the application display
-//                      callback at end of traversal
+#define RIC120302	/*  GG Enable to use the application display
+			          callback at end of traversal
+			          Modified P. Dolbey 09/06/07 to call back
+                           before redrawing the overlayer
 */
 
 /*----------------------------------------------------------------------*/
@@ -62,7 +64,7 @@
    CALL_DEF_LAYER * anunderlayer,
    CALL_DEF_LAYER * anoverlayer
 
-        Redraws all the structures displayed in the specified view.
+	Redraws all the structures displayed in the specified view.
 
    call_togl_redraw_area (aview, anunderlayer, anoverlayer, x, y, width, height)
    CALL_DEF_VIEW * aview,
@@ -70,8 +72,8 @@
    CALL_DEF_LAYER * anoverlayer,
    int x,y,width,height
 
-        Redraws all the structures displayed in the specified view area
-        defined by it upper-left corner and pixel size.
+	Redraws all the structures displayed in the specified view area
+	defined by it upper-left corner and pixel size.
 */
 
 #ifdef G004
@@ -88,17 +90,18 @@
                                        int  nBitsPerPixel);
 
 extern GLboolean OpenGl_AVIWriter_AllowWriting();
+
 #endif
 GLboolean g_fBitmap;
-#endif  /*G004*/
+#endif	/*G004*/
 
 
 void EXPORT
 call_togl_redraw
 (
-        CALL_DEF_VIEW * aview,
-        CALL_DEF_LAYER * anunderlayer,
-        CALL_DEF_LAYER * anoverlayer
+	CALL_DEF_VIEW * aview,
+	CALL_DEF_LAYER * anunderlayer,
+	CALL_DEF_LAYER * anoverlayer
 )
 {
   CMN_KEY_DATA data;
@@ -106,25 +109,33 @@
 
   if ( TsmGetWSAttri (aview->WsId, WSWindow, &data) != TSuccess ) return;
 #ifdef G004
-  if ( !aview->DefBitmap.bitmap ) { /* redrawing view to the window */
-#endif
-    if (TxglWinset (call_thedisplay, (Window) data.ldata) == TSuccess) {
-      call_func_redraw_all_structs_begin (aview->WsId);
-      if (anunderlayer->ptrLayer)
-        call_togl_redraw_layer2d (aview, anunderlayer);
-      call_func_redraw_all_structs_proc (aview->WsId);
-      if (anoverlayer->ptrLayer)
-        call_togl_redraw_layer2d (aview, anoverlayer);
-#ifdef RIC120302
-      call_subr_displayCB(aview,OCC_REDRAW_WINDOW);
+  if ( !aview->DefBitmap.bitmap ) {	/* redrawing view to the window */
 #endif
-      call_func_redraw_all_structs_end (aview->WsId, swap);
-      call_togl_redraw_immediat_mode (aview);
-    }
+	if (TxglWinset (call_thedisplay, (Window) data.ldata) == TSuccess) {
+	    call_func_redraw_all_structs_begin (aview->WsId);
+	    if (anunderlayer->ptrLayer)
+		call_togl_redraw_layer2d (aview, anunderlayer);
+	    call_func_redraw_all_structs_proc (aview->WsId);
+
+		/* Proposed by P.Dolbey and revised to keep also the old callback */
+        #ifdef RIC120302
+			 call_subr_displayCB(aview, OCC_REDRAW_WINDOW | OCC_PRE_OVERLAY );
+		#endif
+
+		if (anoverlayer->ptrLayer)
+		call_togl_redraw_layer2d (aview, anoverlayer);
+
+		#ifdef RIC120302
+			 call_subr_displayCB(aview,OCC_REDRAW_WINDOW);
+		#endif
+		
+	    call_func_redraw_all_structs_end (aview->WsId, swap);
+	    call_togl_redraw_immediat_mode (aview);
+	}
 #ifdef G004
-  } else {
-    CMN_KEY_DATA          pixdata;
-    GLenum                errorcode = 0;
+   } else {
+     CMN_KEY_DATA          pixdata;
+     GLenum                errorcode = 0;
 #ifndef WNT
     int  n,sdesc[11];
     XVisualInfo*        XVInfo = NULL;
@@ -134,8 +145,8 @@
 
     XGetWindowAttributes ( call_thedisplay, (Window)data.ldata , &wattr );
 #ifdef IMP100701
-    if( aview->DefBitmap.depth > 0 )
-      wattr.depth = aview->DefBitmap.depth;
+   if( aview->DefBitmap.depth > 0 )
+     wattr.depth = aview->DefBitmap.depth;
 #endif
     n = 0;
     sdesc[n] = GLX_RGBA; n++;
@@ -151,33 +162,33 @@
     sdesc[n] = ( wattr.depth <= 8 ) ? 0 : 1; n++;
     sdesc[n] = GLX_BLUE_SIZE; n++;
     sdesc[n] = ( wattr.depth <= 8 ) ? 0 : 1; n++;
-#ifdef BUG      /* Redraw always in single buffer mode and don't swap ! */
+#ifdef BUG	/* Redraw always in single buffer mode and don't swap ! */
     char                string[CALL_DEF_STRING_LENGTH];
     if ( !call_util_osd_getenv ("CALL_OPENGL_NO_DBF", string, CALL_DEF_STRING_LENGTH) )
       { sdesc[n] = GLX_DOUBLEBUFFER; n++; }
 #endif
-    sdesc[n] = None; n++;
-
-    XVInfo = glXChooseVisual ( call_thedisplay, DefaultScreen(call_thedisplay), sdesc );
-    if ( !XVInfo ) {
-      fprintf ( stderr, "Visual not available\n" );
-      return;
-    }
+     sdesc[n] = None; n++;
 
-    theContext = glXCreateContext ( call_thedisplay, XVInfo, NULL, GL_FALSE );
-
-    theGLXPixmap = glXCreateGLXPixmap ( call_thedisplay, XVInfo, aview->DefBitmap.bitmap );
-
-    if ( ! glXMakeCurrent (call_thedisplay, theGLXPixmap, theContext) )
-      {
-        errorcode = glGetError ();
-        fprintf ( stderr, "glXMakeCurrent failed: %d %s\n", errorcode, gluErrorString(errorcode) );
-        return;
-      }
+     XVInfo = glXChooseVisual ( call_thedisplay, DefaultScreen(call_thedisplay), sdesc );
+     if ( !XVInfo ) {
+       fprintf ( stderr, "Visual not available\n" );
+       return;
+     }
+
+     theContext = glXCreateContext ( call_thedisplay, XVInfo, NULL, GL_FALSE );
+
+     theGLXPixmap = glXCreateGLXPixmap ( call_thedisplay, XVInfo, aview->DefBitmap.bitmap );
+
+     if ( ! glXMakeCurrent (call_thedisplay, theGLXPixmap, theContext) )
+          {
+             errorcode = glGetError ();
+             fprintf ( stderr, "glXMakeCurrent failed: %d %s\n", errorcode, gluErrorString(errorcode) );
+             return;
+          }
 #else /* WindowsXX code here */
     HGLRC               hglrc_old = wglGetCurrentContext ();
     HDC                 hdc_old = wglGetCurrentDC ();
-    HDC                 hdc = (HDC) aview->DefBitmap.bitmap;
+    HDC		      hdc = (HDC) aview->DefBitmap.bitmap;
     HGLRC               hglrc = wglCreateContext (hdc);
 
     if ( !hglrc || !wglMakeCurrent (hdc, hglrc) )
@@ -187,51 +198,58 @@
         return;
       }
 #endif
-    pixdata.ldata = aview->DefBitmap.width;
-    if ( TsmSetWSAttri (aview->WsId, WSWidth, &pixdata) != TSuccess ) return;
-    pixdata.ldata = aview->DefBitmap.height;
-    if ( TsmSetWSAttri (aview->WsId, WSHeight, &pixdata) != TSuccess ) return;
-
-    /* generate new display lists */
-    TsmInitAttributes();
-
-    glLightModeli((GLenum)GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
-
-    glMatrixMode ( GL_MODELVIEW );
-    glViewport ( 0, 0, aview->DefBitmap.width, aview->DefBitmap.height );
-
-    glDrawBuffer ( GL_FRONT );
-
-    /* redrawing ... */
-    g_fBitmap = GL_TRUE;
-    call_func_redraw_all_structs_begin (aview->WsId);
-    if (anunderlayer->ptrLayer)
-      call_togl_redraw_layer2d (aview, anunderlayer);
-    call_func_redraw_all_structs_proc (aview->WsId);
-    if (anoverlayer->ptrLayer)
-      call_togl_redraw_layer2d (aview, anoverlayer);
-#ifdef RIC120302
-    call_subr_displayCB(aview,OCC_REDRAW_BITMAP);
-#endif
-    call_func_redraw_all_structs_end (aview->WsId, 0);
+          pixdata.ldata = aview->DefBitmap.width;
+          if ( TsmSetWSAttri (aview->WsId, WSWidth, &pixdata) != TSuccess ) return;
+          pixdata.ldata = aview->DefBitmap.height;
+          if ( TsmSetWSAttri (aview->WsId, WSHeight, &pixdata) != TSuccess ) return;
+
+          /* generate new display lists */
+          TsmInitAttributes();
+
+          glLightModeli((GLenum)GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
+
+          glMatrixMode ( GL_MODELVIEW );
+          glViewport ( 0, 0, aview->DefBitmap.width, aview->DefBitmap.height );
+
+          glDrawBuffer ( GL_FRONT );
+
+          /* redrawing ... */
+          g_fBitmap = GL_TRUE;
+          call_func_redraw_all_structs_begin (aview->WsId);
+          if (anunderlayer->ptrLayer)
+          	call_togl_redraw_layer2d (aview, anunderlayer);
+          call_func_redraw_all_structs_proc (aview->WsId);
+
+			/* Proposed by P.Dolbey and revised to keep also the old callback */
+			#ifdef RIC120302
+				 call_subr_displayCB(aview,OCC_REDRAW_BITMAP |OCC_PRE_OVERLAY);
+			#endif
+      
+			if (anoverlayer->ptrLayer)
+          	call_togl_redraw_layer2d (aview, anoverlayer);
+		
+			#ifdef RIC120302
+				 call_subr_displayCB(aview,OCC_REDRAW_BITMAP);
+			#endif
+		
+          call_func_redraw_all_structs_end (aview->WsId, 0);
 
-    call_togl_redraw_immediat_mode (aview);
-    g_fBitmap = GL_FALSE;
+          call_togl_redraw_immediat_mode (aview);
+          g_fBitmap = GL_FALSE;
 
-    glFinish();
+          glFinish();
 
-    /* cleaning up ... */
+          /* cleaning up ... */
 #ifndef WNT
-    glXMakeCurrent ( call_thedisplay, None, NULL );
-    glXDestroyContext ( call_thedisplay, theContext );
-    glXDestroyGLXPixmap ( call_thedisplay, theGLXPixmap );
+          glXMakeCurrent ( call_thedisplay, None, NULL );
+          glXDestroyContext ( call_thedisplay, theContext );
+          glXDestroyGLXPixmap ( call_thedisplay, theGLXPixmap );
 #else
-    wglMakeCurrent ( hdc_old, hglrc_old );
-    wglDeleteContext ( hglrc );
+          wglMakeCurrent ( hdc_old, hglrc_old );
+          wglDeleteContext ( hglrc );
 #endif
-  }
-#endif  /*G004*/
-
+	}
+#endif	/*G004*/
 #ifdef WNT
   if (OpenGl_AVIWriter_AVIWriter &&
       OpenGl_AVIWriter_AllowWriting()  /*aview->Context.ZBufferActivity*/)
@@ -256,16 +274,16 @@
   }
 #endif
 
-  return;
+	return;
 }
 
 void EXPORT
 call_togl_redraw_area
 (
- CALL_DEF_VIEW * aview,
- CALL_DEF_LAYER * anunderlayer,
- CALL_DEF_LAYER * anoverlayer,
- int x, int y, int width, int height
+	CALL_DEF_VIEW * aview,
+	CALL_DEF_LAYER * anunderlayer,
+	CALL_DEF_LAYER * anoverlayer,
+	int x, int y, int width, int height
 )
 {
   CMN_KEY_DATA data;
@@ -273,36 +291,44 @@
 /*
   When the exposure area size is > window size / 2 do a full redraw.
 */
-  if( width*height > 
-      (int)(aview->DefWindow.dx*aview->DefWindow.dy)/2 ) {
-    call_togl_redraw(aview,anunderlayer,anoverlayer);
-    return;
-  }
+	if( width*height > 
+		(int)(aview->DefWindow.dx*aview->DefWindow.dy)/2 ) {
+	  call_togl_redraw(aview,anunderlayer,anoverlayer);
+	  return;
+	}
 /*
   Or redraw only the area in the front buffer
 */
-  TsmGetWSAttri (aview->WsId, WSWindow, &data);
-  if (TxglWinset (call_thedisplay, (Window) data.ldata) == TSuccess) {
-    GLint buffer;
-    glGetIntegerv(GL_DRAW_BUFFER,&buffer);
-    if( buffer != GL_FRONT ) glDrawBuffer (GL_FRONT);
-    glEnable( GL_SCISSOR_TEST );
-    glScissor( (GLint)x, 
-               (GLint)((int)aview->DefWindow.dy - (y+height)), 
-               (GLsizei)width, (GLsizei)height);
-    call_func_redraw_all_structs_begin (aview->WsId);
-    if (anunderlayer->ptrLayer)
-      call_togl_redraw_layer2d (aview, anunderlayer);
-    call_func_redraw_all_structs_proc (aview->WsId);
-    if (anoverlayer->ptrLayer)
-      call_togl_redraw_layer2d (aview, anoverlayer);
-#ifdef RIC120302
-    call_subr_displayCB(aview,OCC_REDRAW_WINDOWAREA);
-#endif
-    call_func_redraw_all_structs_end (aview->WsId, 0);
-    call_togl_redraw_immediat_mode (aview);
-    glFlush();
-    glDisable( GL_SCISSOR_TEST );
-    if( buffer != GL_FRONT ) glDrawBuffer (buffer);
-  }
+	TsmGetWSAttri (aview->WsId, WSWindow, &data);
+	if (TxglWinset (call_thedisplay, (Window) data.ldata) == TSuccess) {
+	    GLint buffer;
+	    glGetIntegerv(GL_DRAW_BUFFER,&buffer);
+	    if( buffer != GL_FRONT ) glDrawBuffer (GL_FRONT);
+	    glEnable( GL_SCISSOR_TEST );
+	    glScissor( (GLint)x, 
+		(GLint)((int)aview->DefWindow.dy - (y+height)), 
+				(GLsizei)width, (GLsizei)height);
+	    call_func_redraw_all_structs_begin (aview->WsId);
+	    if (anunderlayer->ptrLayer)
+		call_togl_redraw_layer2d (aview, anunderlayer);
+	    call_func_redraw_all_structs_proc (aview->WsId);
+
+		/* Proposed by P.Dolbey and revised to keep also the old callback */
+		#ifdef RIC120302
+			call_subr_displayCB(aview,OCC_REDRAW_WINDOWAREA|OCC_PRE_OVERLAY);
+		#endif
+
+		if (anoverlayer->ptrLayer)
+			call_togl_redraw_layer2d (aview, anoverlayer);
+
+		#ifdef RIC120302
+			call_subr_displayCB(aview,OCC_REDRAW_WINDOWAREA );
+		#endif
+
+	    call_func_redraw_all_structs_end (aview->WsId, 0);
+	    call_togl_redraw_immediat_mode (aview);
+	    glFlush();
+	    glDisable( GL_SCISSOR_TEST );
+	    if( buffer != GL_FRONT ) glDrawBuffer (buffer);
+	}
 }
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_unproject_raster.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_togl_unproject_raster.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_unproject_raster.c	2008-07-25 16:03:54.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_togl_unproject_raster.c	2009-10-03 01:04:23.000000000 +0200
@@ -41,7 +41,12 @@
 Tint xr, yr;
 
 	xr = ixr;
-	yr = yM-ym-iyr;
+     /* 
+	  Patched by P.Dolbey: the window pixel height decreased by one 
+        in order for yr to remain within valid coordinate range [0; Ym -1]
+	  where Ym means window pixel height.
+	*/
+	yr = (yM-1)-ym-iyr;
 	result = TelUnProjectionRaster (wsid, xr, yr, x, y, z);
 
 	if (result == TSuccess)
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_triedron.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_triedron.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_triedron.c	2005-04-21 15:09:04.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_triedron.c	2009-10-03 01:04:22.000000000 +0200
@@ -31,7 +31,9 @@
 
 #define OCC2934         /* SAN 22/01/04 Texture-mapped fonts on WNT */
 
-#define OCC7667         /* asl Export to vector graphic file
+#define OCC7667         /* asl Export to vector graphic file */
+
+#define QTOCC_PATCH		/* Active QtOPENCASCADE patches */
 
 /*----------------------------------------------------------------------*/
 /*
@@ -42,6 +44,9 @@
 #include <X11/Xlib.h>
 #endif
 #include <OpenGl_tgl_all.h>
+/* SAN */
+#include <OpenGl_tgl_tox.h>
+/* SAN */
 
 
 #include <stddef.h>
@@ -306,6 +311,18 @@
     GLint mode;
     char AxeName[2]="X\0";
 
+#ifdef QTOCC_PATCH /* PCD 10/02/08 */
+	/* Fix to problem with clipping planes chopping off pieces of the triedron */
+#ifdef QT_OCC_PATCH_ADDON /* VSR 27/02/09 - roll back: performance regression */
+	GLboolean isPlaneActive[GL_MAX_CLIP_PLANES ]; 
+
+	/* Backup the clip planes.         */
+	for (ii = 0; ii < GL_MAX_CLIP_PLANES ; ii++) {
+		isPlaneActive[ii] = glIsEnabled(GL_CLIP_PLANE0 + ii);
+		glDisable(GL_CLIP_PLANE0 + ii);
+	}
+#endif /* VSR 27/02/09 */
+#endif /* PCD 10/02/08 */
 
     /* 
      * Lecture des Init. du Triedre 
@@ -480,6 +497,16 @@
     glLineWidth (TriedronWidth);
 #endif
 
+#ifdef QTOCC_PATCH /* Fotis Sioutis 2007-11-14 15:06 
+	 I have also seen in previous posts that the view trihedron in V3d_WIREFRAME mode 
+	 changes colors depending on the state of the view. This behaviour can be easily 
+	 corrected by altering call_triedron_redraw function in OpenGl_triedron.c of TKOpengl.
+	 The only change needed is to erase the LightOff() function that is called before the 
+	 Axis name drawing and move this function call just before the initial axis drawing.
+	 Below is the code portion with the modification.I don't know if this is considered to 
+	 be a bug but anyway i believe it might help some of you out there.*/
+	LightOff();
+#endif
 
     /* dessin des axes */
     glBegin(GL_LINES);
@@ -695,6 +722,17 @@
 #endif
      */
 
+#ifdef QTOCC_PATCH /* PCD 10/02/08 */
+#ifdef QT_OCC_PATCH_ADDON /* VSR 27/02/09 - roll back: performance regression */
+	/* Recover the clip planes */
+	 for (ii = 0; ii < GL_MAX_CLIP_PLANES ; ii++) {
+		if (isPlaneActive[ii]) { 
+			glEnable(GL_CLIP_PLANE0 + ii);
+		}
+	}
+#endif /* VSR 27/02/09 */
+#endif /* PCD 10/02/08 */
+
     /* 
      * restauration du contexte des matrices
      */
@@ -763,6 +801,21 @@
     GLdouble aAxisDiametr = 0.05;
     ZBUF_STRUCT* aParam;
 
+#ifdef QTOCC_PATCH 
+	GLint df;                                       /* PCD 17/06/07	*/			
+	GLfloat aNULLColor[] = { 0.0, 0.0, 0.0, 0.0f }; /* FS 21/01/08 */
+	/* Fix to problem with clipping planes chopping off pieces of the triedron   */
+	GLboolean isPlaneActive[GL_MAX_CLIP_PLANES ];   /* PCD 10/02/08 */
+	int i;
+#ifdef QT_OCC_PATCH_ADDON /* VSR 27/02/09 - roll back: performance regression */
+
+	/* Backup the clip planes. */
+	for (i = 0; i < GL_MAX_CLIP_PLANES ; i++) {
+		isPlaneActive[i] = glIsEnabled(GL_CLIP_PLANE0 + i);
+		glDisable(GL_CLIP_PLANE0 + i);
+	}
+#endif /* VSR 27/02/09 */
+#endif
 
     /* 
      * Lecture des Init. du Triedre 
@@ -830,8 +883,16 @@
 	       (GLdouble *)modelMatrix, (GLdouble *)projMatrix, aViewPort,
 	       &aWinCoord[0], &aWinCoord[1], &aWinCoord[2]);
 
+#ifdef QTOCC_PATCH /* PCD 29/09/2008 */
+	/* Simple code modification recommended by Fotis Sioutis and Peter Dolbey  */
+	/* to remove the irritating default behaviour of triedrons using V3d_ZBUFFER   */
+	/* which causes the glyph to jump around the screen when the origin moves offscreen. */
+	isWithinView = GL_FALSE;
+#else
+	/* Original code */
     isWithinView = !((aWinCoord[0]<aViewPort[0]) || (aWinCoord[0]>aViewPort[2]) ||
 		    (aWinCoord[1]<aViewPort[1]) || (aWinCoord[1]>aViewPort[3]));
+#endif
 
     if (!isWithinView) {
       /* Annulate translation matrix */
@@ -908,9 +969,18 @@
     
     aIsDepthEnabled = glIsEnabled(GL_DEPTH_TEST);
 #ifndef BUG
-    aIsDepthMaskEnabled = glIsEnabled(GL_DEPTH_WRITEMASK);
+
+#ifdef QTOCC_PATCH 	/*PCD 02/07/07   */
+	/* GL_DEPTH_WRITEMASK is not a valid argument to glIsEnabled, the  */
+	/* original code is shown to be broken when run under an OpenGL debugger  */
+	/* like GLIntercept. This is the correct way to retrieve the mask value.  */
+	glGetBooleanv(GL_DEPTH_WRITEMASK, &aIsDepthMaskEnabled); 
+#else
+	aIsDepthMaskEnabled = glIsEnabled(GL_DEPTH_WRITEMASK);
 #endif
 
+#endif 
+
     /* Create cylinder for axis */
     gluQuadricDrawStyle(aQuadric, GLU_FILL); /* smooth shaded */
     gluQuadricNormals(aQuadric, GLU_FLAT);
@@ -924,7 +994,11 @@
     glEndList();
     /* Central sphere */
     glNewList(startList + 2, GL_COMPILE);
-      gluSphere(aQuadric, aCylinderDiametr, NbFacettes, NbFacettes);
+#ifdef QTOCC_PATCH
+      gluSphere(aQuadric, aCylinderDiametr * 2, NbFacettes, NbFacettes);
+#else
+	  gluSphere(aQuadric, aCylinderDiametr, NbFacettes, NbFacettes);
+#endif
     glEndList();
     /* End disk */
     gluQuadricOrientation(aQuadric,GLU_INSIDE); /*szv*/
@@ -932,13 +1006,43 @@
       gluDisk(aQuadric, aCylinderDiametr, aConeDiametr, NbFacettes, 1/*szv:2*/);
     glEndList();
 
+#ifdef QTOCC_PATCH
+    /* Store previous attributes */
+    glPushAttrib(GL_LIGHTING_BIT | GL_POLYGON_BIT);
+	LightOn();
+#else
     LightOn();
 
     /* Store previous attributes */
     glPushAttrib(GL_LIGHTING_BIT | GL_POLYGON_BIT);
+#endif
     
     glCullFace(GL_BACK);
     glEnable(GL_CULL_FACE);
+
+#ifdef QTOCC_PATCH /*Fotis Sioutis | 2008-01-21 10:55 
+	 In the function call_zbuffer_triedron_redraw of TKOpengl, 
+	 the z buffered trihedron changes colors in case there 
+	 is an object in the scene that has an explicit material 
+	 attached to it.In the trihedron display loop, 
+	 GL_COLOR_MATERIAL is enabled, but only the GL_DIFFUSE 
+	 parameter is utilized in glColorMaterial(...).
+	 This causes the last ambient,specular and emission values 
+	 used, to stay at the stack and applied to the trihedron
+	 (which causes the color change).
+	 A fix is proposed , to change GL_DIFFUSE to 
+	 GL_AMBIENT_AND_DIFFUSE in glColorMaterial call in 
+	 line 946.The above of course will leave unchanged 
+	 the SPECULAR and EMISSION values.
+	 Another proposal which would fix 100% the problem 
+	 is to use glMaterial instead of glColor on the trihedron 
+	 drawing loop.               */
+	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, aNULLColor);
+	glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, aNULLColor);
+	glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, aNULLColor);
+
+	glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 0.);
+#endif
  
     glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
     glEnable(GL_COLOR_MATERIAL);
@@ -955,12 +1059,16 @@
 #endif
 #ifndef BUG
     if (!aIsDepthMaskEnabled)  {
-      glEnable(GL_DEPTH_WRITEMASK);
+	/* This is how the depthmask needs to be re-enabled...*/
+	glDepthMask(GL_TRUE);
+	/* ...and not this stuff below */
     }
 #endif
  
     glMatrixMode(GL_MODELVIEW);
-
+#ifdef QTOCC_PATCH /* PCD 17/06/07  */
+	glGetIntegerv (GL_DEPTH_FUNC, &df); 
+#else
     /*szv:if (isWithinView) {*/
       glDepthFunc(GL_GREATER);
       glPushMatrix();
@@ -1010,6 +1118,20 @@
 
       glDepthFunc(GL_LESS);
     /*szv:}*/
+#endif
+
+#ifdef QTOCC_PATCH
+    for (i = 0; i < 2; i++) /* PCD 11/02/08 Two pass method */
+	{
+		if (i == 0) /*  First pass  */
+		{                          
+			glDepthFunc(GL_ALWAYS); 
+		}
+		else
+		{
+			glDepthFunc(GL_LEQUAL); 
+		}
+#endif
 
     glPushMatrix();
     glPushMatrix();
@@ -1043,20 +1165,34 @@
     glCallList(startList + 3);
     glCallList(startList + 1);
     glPopMatrix();
+
+#ifdef QTOCC_PATCH
+	}
+#endif
     
     if (!aIsDepthEnabled) 
       glDisable(GL_DEPTH_TEST);
 #ifndef BUG
     if (!aIsDepthMaskEnabled)
+
+#ifdef QTOCC_PATCH /*PCD 02/07/07   */
+	glDepthMask(GL_FALSE);
+#else
       glDisable(GL_DEPTH_WRITEMASK);
 #endif
 
+#endif
     glDisable(GL_CULL_FACE);
     glDisable(GL_COLOR_MATERIAL);
 
     gluDeleteQuadric(aQuadric);
     glColor3fv (TriedronColor);
 
+#ifdef QTOCC_PATCH /* PCD 11/02/08 */
+	/* Always write the text */
+	glDepthFunc(GL_ALWAYS); 
+#endif
+
     glPopAttrib();
 
      /* fleches au bout des axes (= cones de la couleur demandee) */
@@ -1074,6 +1210,10 @@
 
      /* init font */
 #ifndef WNT
+     /* OCC20802 - Specify explicitly the font of small height to be used for axis names.
+        Otherwise, axis names might become too large if the current font 
+        has unsuitable parameters */
+     tXfmfindfont( call_thedisplay, "Courier-Bold", 1. );
      fontBase = tXfmsetfont (1.0F, 1.0F);
 #else
      fontBase = WNTSetFont (1.0F, 1.0F);
@@ -1165,6 +1305,21 @@
 #endif
      */
 
+#ifdef QTOCC_PATCH 
+	/*PCD 17/06/07    */
+	glDepthFunc(df);
+
+	/* PCD 10/02/08  */
+	/* Recover the clip planes */
+#ifdef QT_OCC_PATCH_ADDON /* VSR 27/02/09 - roll back: performance regression */
+	for (i = 0; i < GL_MAX_CLIP_PLANES ; i++) {
+		if (isPlaneActive[i]) { 
+			glEnable(GL_CLIP_PLANE0 + i);
+		}
+	}
+#endif /* VSR 27/02/09 */
+#endif
+
     if (!isWithinView) { /* restore matrix */
       glMatrixMode (GL_PROJECTION);
       glPopMatrix ();
diff -Naur OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_view.c OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_view.c
--- OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_view.c	2008-07-25 16:03:53.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/OpenGl/OpenGl_view.c	2009-10-03 01:04:23.000000000 +0200
@@ -53,8 +53,8 @@
 ************************************************************************/
 
 #define BUC60920        /* GG 010601
-//                      Change the z buffer comparaison for minimizing
-//                      unavailable or unviewable drawing of pixels in the same plane
+                      Change the z buffer comparaison for minimizing
+                      unavailable or unviewable drawing of pixels in the same plane
 */
 
 #define BUC61044       /* 25/10/01 SAV ; added functionality to control gl depth testing
@@ -104,6 +104,7 @@
 /* OCC18942: The new perspective projection matrix is off by default */
 EXPORT extern GLboolean env_sym_perspective; /* defined in OpenGl_togl_begin.c */
 
+
 /*----------------------------------------------------------------------*/
 /*
  * Constantes
@@ -196,15 +197,16 @@
                           Tlimit3  *clip_limit
                         )
 {
-    Tfloat    gx, gy, xsf, ysf, zsf;
-    Tfloat    fpd, bpd;
-
+    Tdouble    gx, gy, xsf, ysf, zsf;
+    Tdouble    fpd, bpd;
+ 
     /* OCC18942 */
     Tfloat    n, f, r, l, t, b, Zprp, dx, dy, VPD;
 
     /* FSXXX */
     /* GLint gdtmp; */
     Tlimit3   vp = { ( float )-1.0, ( float )1.0, ( float )-1.0, ( float )1.0, ( float )1.0, ( float )-1.0 };
+
     Tmatrix3  pmat = { { ( float )1.0, ( float )0.0, ( float )0.0, ( float )0.0 },
                        { ( float )0.0, ( float )1.0, ( float )0.0, ( float )0.0 },
                        { ( float )0.0, ( float )0.0, ( float )1.0, ( float )0.0 },
@@ -292,21 +294,21 @@
                                            mapping->viewport.ymin, mapping->viewport.ymax);
 #endif
 
+   
     /* projection matrix */
     if( mapping->proj == TelParallel )
     {
-
         pmat[2][0] = -gx; pmat[3][0] = mapping->vpd*gx;
         pmat[2][1] = -gy; pmat[3][1] = mapping->vpd*gy;
     }
-    else if ( !env_sym_perspective )/* TelPerspective */
+    else if ( !env_sym_perspective)/* TelPerspective */
     {
         pmat[0][0] = pmat[1][1] = mapping->prp[2] - mapping->vpd;
-        pmat[2][0] = -gx; 
-        pmat[2][1] = -gy; 
+        pmat[2][0] = -gx;
+        pmat[2][1] = -gy;
         pmat[2][3] = ( float )-1.0;
-        pmat[3][0] = mapping->vpd * gx; 
-        pmat[3][1] = mapping->vpd * gy; 
+        pmat[3][0] = mapping->vpd * gx;
+        pmat[3][1] = mapping->vpd * gy;
         pmat[3][3] = mapping->prp[2];
 
         /* modify the next two cells to change clipping policy */
@@ -316,7 +318,7 @@
         pmat[3][2] = fpd * bpd; 
         }
     }
-    /* OCC18942: New approach to calculation of mapping (projection) matrix */
+   /* OCC18942: New approach to calculation of mapping (projection) matrix */
     else 
     {
       dx = mapping->window.xmax - mapping->window.xmin;
@@ -400,16 +402,18 @@
     zsf = (vp.zmax - vp.zmin) / (fpd - bpd);
 
     /* map matrix */
-    mmat[0][0] = xsf, mmat[1][1] = ysf, mmat[2][2] = zsf;
+    mmat[0][0] = xsf;
+	mmat[1][1] = ysf;
+	mmat[2][2] = zsf;
     mmat[3][0] = vp.xmin - xsf*mapping->window.xmin;
     mmat[3][1] = vp.ymin - ysf*mapping->window.ymin;
     mmat[3][2] = vp.zmin - zsf*bpd;
 
     /* multiply to obtain mapping matrix */
-    TelMultiplymat3( mat, pmat, mmat );
-
+	TelMultiplymat3( mat, pmat, mmat );
+    
 #ifdef PRINT
-    printf( "mapping_matrix :\n" );
+    printf( "mapping_matrix :\n");  
     pr_matrix(mat);
 #endif
 }
@@ -458,10 +462,10 @@
         TsmSetWSAttri( Wsid, WSViews, &key ); /* Set defined view data*/
     }
 
-    /* copy view definition to storage table record */
-    /* NOTE: Use the matrices already calculated and stored in vrep */
-    vptr->vrep = *vrep; 
-
+     /* copy view definition to storage table record */
+     /* NOTE: Use the matrices already calculated and stored in vrep */
+    vptr->vrep = *vrep;
+    
 #ifdef CAL_100498
     /* compute inverse transformation matrix */
     TelEvalInverseMatrix( vrep->extra.vrp, vrep->extra.vpn, vrep->extra.vup,
@@ -551,7 +555,8 @@
                               Tmatrix3  rmat  /* Out: Orientation Matrix  */
                             )
 {
-    Tfloat  u[3], v[3], n[3], f;
+	Tfloat  u[3], v[3], n[3], f;
+
 
     /* view plane normal of zero length */
     if( vecmag(vpn) == 0.0 )
@@ -636,7 +641,7 @@
 void
 TelEvalViewMappingMatrixPick( tel_view_mapping mapping /* View Mapping */,
                           Tint *error_ind          /* Out: Error Indicator */,
-                          Tmatrix3 mat             /* Out: Mapping Matrix */,
+                          Tmatrix3 mat             /* Out: Mapping Matrix */,  
                           Tfloat   cx,
                           Tfloat   cy
                         )
@@ -762,6 +767,7 @@
     Debug tool
 +*/
 
+
 #ifdef DEB
 void
 pr_matrix( Tmatrix3 mat )
@@ -855,7 +861,7 @@
         printf("OpenGl_view.c::TelSetViewIndex::glMatrixMode(GL_PROJECTION) \n"); 
 #endif
     glMatrixMode(GL_PROJECTION);
-    glLoadMatrixf((GLfloat *) vptr->vrep.mapping_matrix );
+	glLoadMatrixf((GLfloat *) vptr->vrep.mapping_matrix );
 
 #ifdef TRACE_MAT
     printf( "\nTelSetViewIndex WS : %d, view : %d", Wsid, Vid );
diff -Naur OpenCASCADE6.3.0/ros/src/V3d/V3d_ColorScale.cxx OpenCASCADE6.3.0sp6/ros/src/V3d/V3d_ColorScale.cxx
--- OpenCASCADE6.3.0/ros/src/V3d/V3d_ColorScale.cxx	2008-07-18 16:59:38.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/V3d/V3d_ColorScale.cxx	2009-10-03 01:04:52.000000000 +0200
@@ -1,8 +1,8 @@
-// File:	V3d_ColorScale.cxx
-// Created:	Tue Jun 22 17:44:25 2004
-// Author:	STV
-//Copyright:	Open Cascade 2004
-
+/* File:	V3d_ColorScale.cxx
+   Created:	Tue Jun 22 17:44:25 2004
+   Author:	STV
+   Copyright:	Open Cascade 2004
+*/
 #include <V3d_ColorScale.ixx>
 
 #include <V3d_View.hxx>
@@ -38,8 +38,9 @@
 
 void V3d_ColorScale::Erase()
 {
+
   myDisplay = Standard_False;
-  UpdateColorScale();
+    UpdateColorScale();
 }
 
 Standard_Boolean V3d_ColorScale::IsDisplayed() const
@@ -47,6 +48,7 @@
   return myDisplay;
 }
 
+
 void V3d_ColorScale::UpdateColorScale()
 {
   myLayerMgr->Compute();
@@ -89,24 +91,24 @@
   Standard_Integer aTextH = GetTextHeight();
   Standard_Integer aWidth, anAscent, aDescent;
   TextSize(aText, aTextH, aWidth, anAscent, aDescent);
-//  Standard_Integer anAscent = 3 * aTextH / 4;
+/*  Standard_Integer anAscent = 3 * aTextH / 4;     */
   theLayer->DrawText( theText.ToCString(), X, Y + anAscent, aTextH);
-//  theLayer->DrawText( theText.ToCString(), X, Y, aTextH );
+/*  theLayer->DrawText( theText.ToCString(), X, Y, aTextH );     */
 }
 
 Standard_Integer V3d_ColorScale::TextWidth( const TCollection_ExtendedString& aText ) const
 {
   Standard_Integer aWidth, anAscent, aDescent;
   TextSize(aText, GetTextHeight(), aWidth, anAscent, aDescent);
-//  return 5 * aText.Length();
+/*  return 5 * aText.Length();    */
   return aWidth;
 }
 
 Standard_Integer V3d_ColorScale::TextHeight( const TCollection_ExtendedString& aText ) const
 {
   Standard_Integer aWidth, anAscent, aDescent;
-//  static Standard_Integer TextHeight = 10;
-//  return TextHeight;
+/*  static Standard_Integer TextHeight = 10;       */
+/*  return TextHeight;              */
   TextSize(aText, GetTextHeight(), aWidth, anAscent, aDescent);
   return anAscent+aDescent;
 }
@@ -114,28 +116,27 @@
 void V3d_ColorScale::TextSize (const TCollection_ExtendedString& AText,  const Standard_Integer AHeight, Standard_Integer& AWidth, Standard_Integer& AnAscent, Standard_Integer& ADescent) const 
 {
   const Handle(Visual3d_Layer) &theLayer = myLayerMgr->Overlay();
-  if ( !theLayer.IsNull() ) {
+   if ( !theLayer.IsNull() ) {
     Standard_Real aWidth, anAscent, aDescent;
     TCollection_AsciiString theText( AText.ToExtString(), '?' );
     theLayer->TextSize(theText.ToCString(),AHeight,aWidth,anAscent,aDescent);
-    AWidth = (Standard_Integer)aWidth;
-    AnAscent = (Standard_Integer)anAscent;
-    ADescent = (Standard_Integer)aDescent;
+    AWidth = (Standard_Integer) aWidth;
+    AnAscent = (Standard_Integer) anAscent;
+    ADescent = (Standard_Integer) aDescent;
   } 
   else {
     AWidth=AnAscent=ADescent=0;
   }
 }
 
-void V3d_ColorScale::DrawScale ()
+void V3d_ColorScale::DrawScale()
 {
-  const Handle(V3d_View) &theView = myLayerMgr->View();
+    const Handle(V3d_View) &theView = myLayerMgr->View();
   if ( theView.IsNull() )
     return;
-
   const Handle(Aspect_Window) &theWin = theView->Window();
   if ( theWin.IsNull() )
-    return;
+   return;
 
   Standard_Integer WinWidth( 0 ), WinHeight( 0 );
   theWin->Size( WinWidth, WinHeight );
@@ -147,4 +148,5 @@
   const Standard_Integer H = RealToInt(GetHeight() * WinHeight);
 
   Aspect_ColorScale::DrawScale( theView->BackgroundColor(), X, Y, W, H );
+
 }
diff -Naur OpenCASCADE6.3.0/ros/src/V3d/V3d_View.cxx OpenCASCADE6.3.0sp6/ros/src/V3d/V3d_View.cxx
--- OpenCASCADE6.3.0/ros/src/V3d/V3d_View.cxx	2008-08-15 15:54:10.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/V3d/V3d_View.cxx	2009-10-03 01:04:52.000000000 +0200
@@ -63,71 +63,71 @@
 
 ************************************************************************/
 
-#define GER61351	//GG_15/12/99 Add SetBackgroundColor()
-//				      and BackgroundColor() methods
+#define GER61351	/*GG_15/12/99 Add SetBackgroundColor()
+				      and BackgroundColor() methods */
 
 
-#define IMP240100	//GG
-//			-> Remove PixToRef() method ,use
-//			  instead the equivalent Convert() method.
-//			-> Rename RefToPix() to Convert() method.
-//		        -> Remove the grid computation in Convert()
-//			  method. Use instead the NEW ConvertToGrid() methods.
-//			  Reason is the Convert() method is call by 
-//			  StdSelect_ViewSelector3d_Pick() from
-//			  AIS_InteractiveContext() and it's not possible
-//			  to select an object vertex when the grid is active!
-//			-> Remove grid echo marker definition 
-//			  (reported in the viewer)
-//			-> Add SetProjModel() methods.
-
-#define G003		//EUG 04-10-99
-//			-> computed mode management
-//			   Add SetComputedMode(..) method
-//			-> animation mode management
-//			   Add SetAnimationMode()
-//			-> backfacing management
-//			   Add SetBackFacingModel() method
-
-#define G004		//VKH 15-11-99
-//			-> Add Dump() methods
-//			-> GG 07/03/00 Use the new MMSize()
-//			   method from Aspect_Window class.
-
-#define IMP210200       //GG Add Transparency() method
-
-#define IMP250200	//GG With SetDepth() method, when the requested 
-//			depth is < 0.,
-//			move the view ref point and the eye,instead
-//			only the eye.
-
-#define IMP020300	//GG Don't use ZFitAll in during Rotation
-//			for perf improvment
-
-#define IMP210600	//GG Avoid to have infinite loop when call Rotation() method 
-//			without call before StartRotation().
-//			This problem occurs when CTRL MB3 is maintain press betwwen 2 views.
-
-#define IMP250900	//GG Enable rotation around screen Z axis when
-//			rotation begin far the center of the screen.
-//			Thanks to Patrick REGINSTER (SAMTECH)
-//			GG 21/12/00 Due to a regression on the previous specifications
-//			this new functionnality is right now deactivated
-//			by default (see StartRotation(...,zRotationThreshold)
-//			method.	
-
-#define BUC60952	//GG Enable to rotate around the view axis
-//			and the required view point
-
-#define RIC120302	//GG Add a NEW SetWindow method which enable
-//			to connect a graphic widget and context to OGL.
+#define IMP240100	/*/GG
+			-> Remove PixToRef() method ,use
+			  instead the equivalent Convert() method.
+			-> Rename RefToPix() to Convert() method.
+		        -> Remove the grid computation in Convert()
+			  method. Use instead the NEW ConvertToGrid() methods.
+			  Reason is the Convert() method is call by 
+			  StdSelect_ViewSelector3d_Pick() from
+			  AIS_InteractiveContext() and it's not possible
+			  to select an object vertex when the grid is active!
+			-> Remove grid echo marker definition 
+			  (reported in the viewer)
+			-> Add SetProjModel() methods.
+                                                          */
+#define G003		/*EUG 04-10-99
+			-> computed mode management
+			   Add SetComputedMode(..) method
+			-> animation mode management
+			   Add SetAnimationMode()
+			-> backfacing management
+			   Add SetBackFacingModel() method  */
+
+#define G004		/*VKH 15-11-99
+			-> Add Dump() methods
+			-> GG 07/03/00 Use the new MMSize()
+			   method from Aspect_Window class.    */
+
+#define IMP210200       /*GG Add Transparency() method   */
+
+#define IMP250200	/*GG With SetDepth() method, when the requested 
+			depth is < 0.,
+			move the view ref point and the eye,instead
+			only the eye.    */
+
+#define IMP020300	/*GG Don't use ZFitAll in during Rotation
+			for perf improvment     */
+
+#define IMP210600	/*GG Avoid to have infinite loop when call Rotation() method 
+			without call before StartRotation().
+			This problem occurs when CTRL MB3 is maintain press betwwen 2 views.  */
+
+#define IMP250900	/*GG Enable rotation around screen Z axis when
+			rotation begin far the center of the screen.
+			Thanks to Patrick REGINSTER (SAMTECH)
+			GG 21/12/00 Due to a regression on the previous specifications
+			this new functionnality is right now deactivated
+			by default (see StartRotation(...,zRotationThreshold)
+			method.	
+                                                                        */
+#define BUC60952	/*GG Enable to rotate around the view axis
+			and the required view point         */
+
+#define RIC120302	/*GG Add a NEW SetWindow method which enable
+			to connect a graphic widget and context to OGL.*/
 
-#define IMP260302	//GG To avoid conflicting in Window destructor
-//			nullify this handle in Remove method
+#define IMP260302	/*GG To avoid conflicting in Window destructor
+			nullify this handle in Remove method      */
 
-#define OCC280          //SAV fix for FitAll problem in the perspective view.
+#define OCC280          /*SAV fix for FitAll problem in the perspective view.    */
 
-#define OCC1188         //SAV Added methods to set background image
+#define OCC1188         /*SAV Added methods to set background image */
 
 /*----------------------------------------------------------------------*/
 /*
@@ -150,11 +150,10 @@
 #include <TColStd_Array2OfReal.hxx>
 #include <Visual3d_TransientManager.hxx>
 #include <Precision.hxx>
-
-// S3892
+/* S3892     */
 #include <Graphic3d_AspectMarker3d.hxx>
 
-// S3603
+/* S3603*/
 #include <Aspect_GenericColorMap.hxx>
 #include <Aspect_TypeMap.hxx>
 #include <Aspect_WidthMap.hxx>
@@ -172,13 +171,13 @@
 # define V3d_FLAG_ANIMATION    	0x00000001
 # define V3d_FLAG_DEGENERATION 	0x00000002
 # define V3d_FLAG_COMPUTATION 	0x00000004
-#endif  // G003
+#endif  /* G003  */
 
-// Tumble
+/* Tumble*/
 #include <OSD_Timer.hxx>
 static OSD_Timer FullTimer;
 
-// Perspective
+/* Perspective  */
 #include <OSD_Environment.hxx>
 
 /*----------------------------------------------------------------------*/
@@ -189,8 +188,8 @@
 #define Zmargin 1.
 #define DEUXPI (2.*Standard_PI)
 
-// en cas NO_TRACE_ECHO et de NO_TRACE_POINTS, dans V3d_View_4.cxx ET dans
-// V3d_View.cxx, virer MyGridEchoStructure et MyGridEchoGroup dans le cdl
+/* en cas NO_TRACE_ECHO et de NO_TRACE_POINTS, dans V3d_View_4.cxx ET dans  */
+/* V3d_View.cxx, virer MyGridEchoStructure et MyGridEchoGroup dans le cdl  */
 #define NO_TRACE_ECHO 
 #define NO_TRACE_POINTS
 
@@ -270,10 +269,10 @@
 return MyProjReferencePoint;
 }
 #define MyProjReferencePoint _MyProjReferencePoint()
-#endif // LOPTIM
+#endif /* LOPTIM    */
 
 /*----------------------------------------------------------------------*/
-//-Constructors
+/*-Constructors*/
 
 V3d_View::V3d_View(const Handle(V3d_Viewer)& VM, const V3d_TypeOfView Type ) :
 MyType ( Type ),
@@ -284,33 +283,33 @@
 myActiveLightsIterator(),
 myActivePlanesIterator(),
 SwitchSetFront(Standard_False),
-MyTrsf (1, 4, 1, 4),                                    // S3892
+MyTrsf (1, 4, 1, 4),                                    /* S3892 */
 MyProjModel(V3d_TPM_SCREEN)
 #if defined(TRACE_POINTS)
-,MyGridEchoStructure (new Graphic3d_Structure (VM->Viewer ())),  // S3892
-MyGridEchoGroup (new Graphic3d_Group (MyGridEchoStructure))            // S3892
+,MyGridEchoStructure (new Graphic3d_Structure (VM->Viewer ())),  /* S3892    */
+MyGridEchoGroup (new Graphic3d_Group (MyGridEchoStructure))            /* S3892  */
 #endif
 {
 
   myImmediateUpdate = Standard_False;
   MyView = new Visual3d_View(MyViewer->Viewer());
   
-  // { Debut de recuperation de la definition du ViewContext.
-  // Pas de MyViewContext = MyView->Context() ;
-  // pour permettre a MyView->SetContext de comparer
-  // l'ancien contexte et le nouveau.
-  // Pas de probleme pour MyViewMapping, MyViewOrientation
-  // car MyView->SetViewMapping et MyView->SetViewOrientation
-  // ne cherchent pas a optimiser les modifications apportees
-  // au viewmapping et au vieworientation.
+  /* { Debut de recuperation de la definition du ViewContext.
+   Pas de MyViewContext = MyView->Context() ;
+   pour permettre a MyView->SetContext de comparer
+   l'ancien contexte et le nouveau.
+   Pas de probleme pour MyViewMapping, MyViewOrientation
+   car MyView->SetViewMapping et MyView->SetViewOrientation
+   ne cherchent pas a optimiser les modifications apportees
+   au viewmapping et au vieworientation.   */
   
-  // Aliasing
+  /* Aliasing*/
   if ((MyView->Context ()).AliasingIsOn ())
     MyViewContext.SetAliasingOn ();
   else
     MyViewContext.SetAliasingOff ();
   
-  // DepthCueing
+  /* DepthCueing   */
   MyViewContext.SetDepthCueingBackPlane
     ((MyView->Context ()).DepthCueingBackPlane ());
   MyViewContext.SetDepthCueingFrontPlane
@@ -321,7 +320,7 @@
   else
     MyViewContext.SetDepthCueingOff ();
   
-  // ZClipping
+  /* ZClipping  */
   MyViewContext.SetZClippingBackPlane
     ((MyView->Context ()).ZClippingBackPlane ());
   MyViewContext.SetZClippingFrontPlane
@@ -337,14 +336,14 @@
   else
     MyViewContext.SetBackZClippingOff ();
   
-  // Visualisation et Shading Model
+  /* Visualisation et Shading Model   */
   MyViewContext.SetModel ((MyView->Context ()).Model ());
   MyViewContext.SetVisualization ((MyView->Context ()).Visualization ());
   
-  // Texture Mapping
+  /* Texture Mapping
   MyViewContext.SetSurfaceDetail (MyView->Context ().SurfaceDetail ());
   MyViewContext.SetTextureEnv (MyView->Context ().TextureEnv ());
-  // } Fin de recuperation de la definition du ViewContext.
+  /* } Fin de recuperation de la definition du ViewContext.     */
   
   MyViewMapping = MyView->ViewMapping() ;
   MyViewOrientation = MyView->ViewOrientation() ;
@@ -371,7 +370,7 @@
   Init();
   myImmediateUpdate = Standard_True;
 
-  // S3892
+  /* S3892  */
 #ifndef IMP240100
 #if defined(TRACE_POINTS)
 Handle(Graphic3d_AspectMarker3d) MarkerAttrib = new Graphic3d_AspectMarker3d ();
@@ -380,11 +379,11 @@
   MarkerAttrib->SetType (Aspect_TOM_STAR);
   MyGridEchoStructure->SetPrimitivesAspect (MarkerAttrib);
 #endif
-#endif	//IMP240100
+#endif	/*IMP240100  */
 
 #ifdef G003
   MyAnimationFlags = 0;
-#endif  // G003
+#endif  /* G003     */
 
 #ifdef IMP210200
   MyTransparencyFlag = Standard_False;
@@ -402,11 +401,11 @@
 myActiveLightsIterator(),
 myActivePlanesIterator(),
 SwitchSetFront(Standard_False),
-MyTrsf (1, 4, 1, 4),                                    // S3892
+MyTrsf (1, 4, 1, 4),                                    /* S3892    */
 MyProjModel(V3d_TPM_SCREEN)
 #if defined(TRACE_POINTS)
-,MyGridEchoStructure (new Graphic3d_Structure (VM->Viewer ())),  // S3892
-MyGridEchoGroup (new Graphic3d_Group (MyGridEchoStructure))             // S3892
+,MyGridEchoStructure (new Graphic3d_Structure (VM->Viewer ())),  /* S3892 */
+MyGridEchoGroup (new Graphic3d_Group (MyGridEchoStructure))             /* S3892 */
 #endif
 {
 
@@ -432,7 +431,7 @@
   Init();
   myImmediateUpdate = Standard_True;
 
-  // S3892
+  /* S3892   */
 #ifndef IMP240100
 #if defined(TRACE_ECHO)
 Handle(Graphic3d_AspectMarker3d) MarkerAttrib = new Graphic3d_AspectMarker3d ();
@@ -441,7 +440,7 @@
   MarkerAttrib->SetType (Aspect_TOM_STAR);
   MyGridEchoStructure->SetPrimitivesAspect (MarkerAttrib);
 #endif
-#endif	//IMP240100
+#endif	/*IMP240100  */
 
 #ifdef G003
   MyAnimationFlags = 0;
@@ -450,7 +449,7 @@
 
 /*----------------------------------------------------------------------*/
 
-//-Methods, in order
+/*-Methods, in order   */
 
 void V3d_View::SetMagnify(const Handle(Aspect_Window)& TheWindow,
                           const Handle(V3d_View)& aPreviousView,
@@ -483,34 +482,34 @@
                                     "V3d_View::SetWindow, window of view already defined");
 
   MyView->SetWindow(TheWindow) ;
-  // SetWindow effectue un SetRatio et modifie le
-  // ViewMapping et ViewMappingDefault de MyView.
+  /* SetWindow effectue un SetRatio et modifie le  */
+  /* ViewMapping et ViewMappingDefault de MyView.  */
   MyViewMapping = MyView->ViewMapping() ;
   MyView->SetContext(MyViewContext) ;
   MyView->SetViewMapping(MyViewMapping) ;
   MyView->SetViewOrientation(MyViewOrientation) ;
   MyView->SetBackground(MyBackground) ;
   MyViewer->SetViewOn(this) ;            
-  //MyView->SetViewMappingDefault();            
+  /*MyView->SetViewMappingDefault();   */         
 #ifdef TRACE_POINTS
-  MyGridEchoStructure->SetInfiniteState (Standard_True);        // S3892
-  MyGridEchoStructure->Display ();                              // S3892
+  MyGridEchoStructure->SetInfiniteState (Standard_True);        /* S3892*/
+  MyGridEchoStructure->Display ();                              /* S3892*/
 #endif
   MyView->Redraw() ;
   MyWindow = TheWindow;
 }
 
-// RIC120302
+/* RIC120302     */
 /*----------------------------------------------------------------------*/
 
-void V3d_View::SetWindow(const Handle(Aspect_Window)&      aWindow,
-			 const Aspect_RenderingContext     aContext,
+void V3d_View::SetWindow(const Handle(Aspect_Window)& aWindow,
+			 const Aspect_RenderingContext aContext,
 			 const Aspect_GraphicCallbackProc& aDisplayCB,
-			 const Standard_Address            aClientData)
-{
+			 const Standard_Address            aClientData) {
+
   Standard_MultiplyDefined_Raise_if( MyView->IsDefined(),
-                                    "V3d_View::SetWindow, "
-                                     "window of view already defined");
+                                    "V3d_View::SetWindow, " 
+				              "window of view already defined");
   MyView->SetWindow(aWindow, aContext, aDisplayCB, aClientData) ;
   MyViewMapping = MyView->ViewMapping() ;
   MyView->SetContext(MyViewContext) ;
@@ -521,7 +520,7 @@
   MyView->Redraw() ;
   MyWindow = aWindow;
 }
-// RIC120302
+/* RIC120302  */
 
 /*----------------------------------------------------------------------*/
 
@@ -557,8 +556,8 @@
   Standard_Boolean TheStatus = Standard_True ;
   
   if( MyView->IsDefined() ) {
-    // CAL 6/11/98
-    // Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;
+    /* CAL 6/11/98  */
+    /* Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ; */
     Standard_Integer Nstruct = MyView->NumberOfDisplayedStructures() ;
     if( Nstruct > 0 ) TheStatus = Standard_False ;
   }
@@ -583,13 +582,13 @@
 /*----------------------------------------------------------------------*/
 
 void V3d_View::MustBeResized() {
-  if ( !MyLayerMgr.IsNull() )
+ if ( !MyLayerMgr.IsNull() )
     MyLayerMgr->Resized();
 
   if( MyView->IsDefined() ) {
     MyView->Resized() ;
     MyViewMapping = MyView->ViewMapping();
-    // MyView->SetViewMappingDefault();
+   /*  MyView->SetViewMappingDefault();  */
     MyView->Redraw();
   }
 }
@@ -609,7 +608,7 @@
   MyBackground.SetColor( C );
   if ( MyView->IsDefined() )
     MyView->SetBackground( MyBackground );
-  if ( !MyLayerMgr.IsNull() )
+   if ( !MyLayerMgr.IsNull() )
     MyLayerMgr->Resized();
 #endif
 }
@@ -622,9 +621,9 @@
   MyBackground.SetColor( Color );
   if ( MyView->IsDefined() )
     MyView->SetBackground( MyBackground );
-  //szv: Why?
+ /*szv: Why?*/
   if ( !MyLayerMgr.IsNull() )
-    MyLayerMgr->Resized();
+    MyLayerMgr->Resized();  
 }
 #endif
 
@@ -906,7 +905,7 @@
 void V3d_View::Rotate(const Standard_Real angle, const Standard_Boolean Start) {
 
   Standard_Real Angle = angle ;
-//  Graphic3d_Vertex Vrp ;
+/*  Graphic3d_Vertex Vrp ;*/
   Graphic3d_Vector Vpn,Vup ;
   TColStd_Array2OfReal Matrix(0,3,0,3) ;
   
@@ -990,7 +989,7 @@
 #ifdef IMP020300
   SetZSize(0.) ;
 #else
-  // Check ZClipping planes
+  /* Check ZClipping planes */
   Standard_Real Zmax ;
   Vrp.Coord(Xat,Yat,Zat) ;
   Zmax = Sqrt( Xat*Xat + Yat*Yat + Zat*Zat) ;
@@ -1051,7 +1050,7 @@
 #ifdef IMP020300
   SetZSize(0.) ;
 #else
-  // Check ZClipping planes
+  /* Check ZClipping planes   */
   Standard_Real Zmax ;
   Vrp.Coord(Xat,Yat,Zat) ;
   Zmax = Sqrt( Xat*Xat + Yat*Yat + Zat*Zat ) ;
@@ -1129,8 +1128,8 @@
   Standard_Boolean update = myImmediateUpdate;
   myImmediateUpdate = Standard_False;
   if( MyProjModel == V3d_TPM_WALKTHROUGH ) {
-      //FMN desactivation temp SetTwist(Angle) ;
-      // Set des infos.
+      /*FMN desactivation temp SetTwist(Angle) ;       */
+      /* Set des infos.                          */
       MyView->SetViewOrientation(MyViewOrientation) ; 
       MyView->SetViewMapping(MyViewMapping) ; 
   } else {
@@ -1139,7 +1138,7 @@
 #ifdef IMP020300
   SetZSize(0.) ;
 #else
-    // Check ZClipping planes
+    /* Check ZClipping planes  */
   Standard_Real Zmax = Sqrt( X*X + Y*Y + Z*Z ) ;
   if( Zmax > MyViewMapping.FrontPlaneDistance() &&
 	MyProjModel == V3d_TPM_SCREEN ) {
@@ -1178,12 +1177,12 @@
     MyViewMapping.SetProjectionReferencePoint(MyProjReferencePoint);
   }
   
-  // Check ZClipping planes
+  /* Check ZClipping planes */
   Standard_Real Xat,Yat,Zat,Xpn,Ypn,Zpn,Xeye,Yeye,Zeye ;
   MyViewReferencePoint.Coord(Xat,Yat,Zat) ;
   MyViewReferencePlane.Coord(Xpn,Ypn,Zpn) ;
 #ifdef IMP250200
-  if( Depth < 0. ) {	// Move the view ref point instead the eye.
+  if( Depth < 0. ) {	/* Move the view ref point instead the eye. */
     Xeye = Xpn*Zrp + Xat ; Yeye = Ypn*Zrp + Yat ; Zeye = Zpn*Zrp + Zat ;
     Zrp = Abs(Depth) ;
     Xat = Xeye - Xpn*Zrp ; Yat = Yeye - Ypn*Zrp ; Zat = Zeye - Zpn*Zrp;
@@ -1240,7 +1239,7 @@
 
   MyViewReferencePlane = V3d::GetProjAxis(Orientation) ; 
   MyViewOrientation.SetViewReferencePlane(MyViewReferencePlane) ;
-  // MSV 14.03.2007: reset ViewReferencePoint to debug LH3D14955
+  /* MSV 14.03.2007: reset ViewReferencePoint to debug LH3D14955 */
   MyViewOrientation.SetViewReferencePoint(Graphic3d_Vertex(0,0,0));
   Standard_Real Xpn=0;
   Standard_Real Ypn=0;
@@ -1290,8 +1289,8 @@
   Standard_Boolean update = myImmediateUpdate;
   myImmediateUpdate = Standard_False;
   if( MyProjModel == V3d_TPM_WALKTHROUGH ) {
-  //FMN desactivation temp SetTwist(Angle) ;  
-  // Set des infos.
+  /*FMN desactivation temp SetTwist(Angle) ;   */
+  /* Set des infos.        */
     MyView->SetViewOrientation(MyViewOrientation) ; 
     MyView->SetViewMapping(MyViewMapping) ; 
   } else {
@@ -1302,7 +1301,7 @@
   SetZSize(0.) ;
 #else
   ImmediateUpdate();
-    // Check ZClipping planes
+    /* Check ZClipping planes  */
   Standard_Real Zmax = Sqrt( X*X + Y*Y + Z*Z ) ;
   if( Zmax > MyViewMapping.FrontPlaneDistance() &&
 	MyProjModel == V3d_TPM_SCREEN ) {
@@ -1397,13 +1396,13 @@
 
   MyView->ViewOrientationReset() ;
   MyViewOrientation = MyView->ViewOrientation() ;
-//OCC4844
-//#ifdef IMP020300
-//  Update();
-//#else
+/*OCC4844 */
+/*#ifdef IMP020300
+  Update();
+#else   */
   ImmediateUpdate();
-//#endif
-//OCC4844
+/*#endif
+OCC4844 */
 }
 
 void V3d_View::Reset( const Standard_Boolean update ) {
@@ -1529,7 +1528,7 @@
   MyViewMapping.SetFrontPlaneDistance(Zmax) ;
   MyViewMapping.SetBackPlaneDistance(-Zmax) ;
 
-  // OCC18942
+  /* OCC18942 */
   if( MyProjModel != V3d_TPM_WALKTHROUGH ) {
     MyViewMapping.SetViewPlaneDistance(MyType == V3d_PERSPECTIVE ? 0. : Zmax) ;
   }
@@ -1541,7 +1540,7 @@
     MyViewContext.SetZClippingBackPlane(Back) ;
     MyView->SetContext(MyViewContext) ;
   }
-//printf(" *** SetZSize(%f)\n",Zmax);
+/*printf(" *** SetZSize(%f)\n",Zmax); */
 }
 
 void V3d_View::SetZoom(const Standard_Real Coef,const Standard_Boolean Start) {
@@ -1556,8 +1555,8 @@
     MyWindowWidth = Abs(Umax - Umin) ;
     MyWindowHeight = Abs(Vmax - Vmin) ;
   }
-
-  // ensure that zoom will not be too small or too big
+  
+  /* ensure that zoom will not be too small or too big  */
   Standard_Real coef = Coef;
   if ( MyWindowWidth < coef * Precision::Confusion() )
     coef = MyWindowWidth / Precision::Confusion();
@@ -1567,7 +1566,7 @@
     coef = MyWindowHeight / Precision::Confusion();
   else if ( MyWindowHeight > coef * 1e12 )
     coef = MyWindowHeight / 1e12;
-
+  
   Dxv = MyWindowWidth/coef; 
   Dyv = MyWindowHeight/coef;
   Umin = MyXwindowCenter - Dxv/2. ; Umax = MyXwindowCenter + Dxv/2. ;
@@ -1607,7 +1606,7 @@
   MyView->ViewManager()->SetUpdateMode(updateMode);
 
   MyView->MinMaxValues(Xmin,Ymin,Zmin,Xmax,Ymax,Zmax) ;
-
+ 
   Standard_Real LIM = ShortRealLast() -1.;
   if     (Abs(Xmin) > LIM || Abs(Ymin) > LIM || Abs(Zmin) > LIM 
       ||  Abs(Xmax) > LIM || Abs(Ymax) > LIM || Abs(Zmax) > LIM ) {
@@ -1650,10 +1649,10 @@
   Standard_Real Xmin,Ymin,Zmin,Xmax,Ymax,Zmax ;
   Standard_Real DxvOld,DyvOld,DxvNew,DyvNew,RapOld,RapNew ;
   Standard_Integer Xpixel,Ypixel;
-  // CAL 6/11/98
-  // Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;
+  /* CAL 6/11/98      */
+  /* Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;  */
   Standard_Integer Nstruct = MyView->NumberOfDisplayedStructures() ;
-  //Standard_Integer Xleft,Yup,Xright,Ylow ;
+  /*Standard_Integer Xleft,Yup,Xright,Ylow ;    */
   Standard_Integer nbPasse = 2;
 
   if( (Nstruct <= 0) || (Coef < 0.) || (Coef > 1.) ) {
@@ -1662,12 +1661,12 @@
 #endif
     return ;
   }
-  //    Update() ;
+  /*    Update() ;  */
   MyProjReferencePoint = MyViewMapping.ProjectionReferencePoint() ;
   MyProjReferencePoint.Coord(Xrp,Yrp,Zrp) ;
   if( MyView->IsDefined() ) {
-    //MyWindow->Position(Xleft,Yup,Xright,Ylow) ;
-    //DxvOld = Abs(Xright - Xleft) ; DyvOld = Abs(Yup - Ylow) ;
+    /*MyWindow->Position(Xleft,Yup,Xright,Ylow) ;   */
+    /*DxvOld = Abs(Xright - Xleft) ; DyvOld = Abs(Yup - Ylow) ;*/
     MyWindow->Size(Xpixel,Ypixel);
     DxvOld = Xpixel; DyvOld = Ypixel;
   } else {
@@ -1742,7 +1741,7 @@
   } 
       
     nbPasse--;    
-  } // while
+  } /* while  */
   
   if(FitZ) {
     ZFitAll(Zmargin);
@@ -1760,8 +1759,8 @@
 
   Standard_Real Xmin,Ymin,Zmin,Xmax,Ymax,Zmax,U,V,W ;
   Standard_Real Umin,Vmin,Wmin,Umax,Vmax,Wmax ;
-  // CAL 6/11/98
-  // Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;
+  /* CAL 6/11/98           */
+  /* Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;   */
   Standard_Integer Nstruct = MyView->NumberOfDisplayedStructures() ;
 
   if( MyType == V3d_PERSPECTIVE ) {
@@ -1782,8 +1781,8 @@
     ImmediateUpdate();
     return ;
   }
-  // CAL 6/11/98
-  // Cas ou la vue ne contient qu'un point
+  /* CAL 6/11/98  */
+  /* Cas ou la vue ne contient qu'un point */
   if (Xmin == Xmax && Ymin == Ymax && Zmin == Zmax) {
     ImmediateUpdate();
     return ;
@@ -1869,12 +1868,12 @@
   Vmin = Min(V,Vmin) ; Vmax = Max(V,Vmax) ;
   Wmin = Min(W,Wmin) ; Wmax = Max(W,Wmax) ;
   
-  // Adjust Z size
+  /* Adjust Z size */
   Wmax = Max(Abs(Wmin),Abs(Wmax)) ;
   Dz = 2.*Wmax + Margin * Wmax;
 
-  // Compute depth value
-  Dx = Abs(Umax - Umin) ; Dy = Abs(Vmax - Vmin) ; // Dz = Abs(Wmax - Wmin);
+  /* Compute depth value  */
+  Dx = Abs(Umax - Umin) ; Dy = Abs(Vmax - Vmin) ; /* Dz = Abs(Wmax - Wmin);  */
   Dx += Margin * Dx; Dy += Margin * Dy;
   Size = Sqrt(Dx*Dx + Dy*Dy + Dz*Dz);
   if( Size > 0. ) {
@@ -1885,6 +1884,7 @@
   ImmediateUpdate();
 }
 
+
 void V3d_View::FitAll(const Standard_Real Xmin, const Standard_Real Ymin, const Standard_Real Xmax, const Standard_Real Ymax) {
   FitAll(MyWindow,Xmin,Ymin,Xmax,Ymax);
 #ifndef IMP020300
@@ -1906,9 +1906,9 @@
 void V3d_View::SetViewMapping(const Visual3d_ViewMapping& VM)
 {
   MyViewMapping = VM;
-  // ajust view type according to mapping projection
-  // NOTE: Might be dangerous, potentially conflicts with the C++ view class
-  // (orthographic or perspective)! Use with care!
+  /* ajust view type according to mapping projection  */
+  /* NOTE: Might be dangerous, potentially conflicts with the C++ view class */
+  /* (orthographic or perspective)! Use with care!*/
   if ( VM.Projection() == Visual3d_TOP_PERSPECTIVE )
     MyType = V3d_PERSPECTIVE;
   else MyType = V3d_ORTHOGRAPHIC;
@@ -1917,6 +1917,7 @@
   ImmediateUpdate();
 }
 
+
 void V3d_View::SetViewMappingDefault() {
   MyView->SetViewMapping(MyViewMapping) ;
   MyView->SetViewMappingDefault();            
@@ -1962,34 +1963,36 @@
   Yv = Vmin + Dyv*(Standard_Real)(Dyw-Yp)/(Standard_Real)Dyw ;
 }
 
-Standard_Integer V3d_View::Convert(const Standard_Real Vv) const 
+Standard_Integer V3d_View::Convert(const Standard_Real Vv) const
 {
+  
   V3d_UnMapped_Raise_if( !MyView->IsDefined(), "view has no window");
 
   Standard_Integer Dxw, Dyw;
   MyWindow->Size(Dxw,Dyw);
-
+  
   Standard_Real Umin,Umax,Vmin,Vmax;
   MyViewMapping.WindowLimit(Umin,Vmin,Umax,Vmax) ;
   Standard_Real Dxv = Umax - Umin;
   return RealToInt ( Dxw * Vv / Dxv );
+  
 }
 
-void V3d_View::Convert(const Standard_Real Xv, const Standard_Real Yv, Standard_Integer& Xp, Standard_Integer& Yp) const 
+void V3d_View::Convert(const Standard_Real Xv, const Standard_Real Yv, Standard_Integer& Xp, Standard_Integer& Yp) const
 {
   V3d_UnMapped_Raise_if( !MyView->IsDefined(), "view has no window");
 
   Standard_Integer Dxw, Dyw;
   MyWindow->Size(Dxw,Dyw);
-
+  
   Standard_Real Umin,Umax,Vmin,Vmax;
   MyViewMapping.WindowLimit(Umin,Vmin,Umax,Vmax) ;
   Standard_Real Dxv = Umax - Umin; 
   Standard_Real Dyv = Vmax - Vmin;
 
-  // CAL 15/12/93 warning:  double  assigned to  int
+  /* CAL 15/12/93 warning:  double  assigned to  int     */
   Xp = RealToInt (Dxw*(Xv - Umin)/Dxv);
-  // CAL 15/12/93 warning:  double  assigned to  int
+  /* CAL 15/12/93 warning:  double  assigned to  int    */
   Yp = Dyw - RealToInt (Dyw*(Yv - Vmin)/Dyv);
 }
 
@@ -2068,22 +2071,22 @@
   (MyViewer->Viewer())->ConvertCoord(MyWindow,Vrp,Xp,Yp) ;
 }
 
-void V3d_View::Project(const Standard_Real X, const Standard_Real Y, const Standard_Real Z, Standard_Real &Xp, Standard_Real &Yp) const
-{
-  if ( MyType != V3d_PERSPECTIVE )
+void V3d_View::Project(const Standard_Real X, const Standard_Real Y, const Standard_Real Z, Standard_Real &Xp, Standard_Real &Yp) const {
+ 
+   if ( MyType != V3d_PERSPECTIVE )
   {
-    // use old implementation
+    /* use old implementation        */
     Standard_Real Zp;
     MyView->Projects( X, Y, Z, Xp, Yp, Zp );
   }
   else
   {
-    // NKV - Using raster projection
+    /* NKV - Using raster projection   */
     Standard_Integer Xpx, Ypx;
     Convert(X, Y, Z, Xpx, Ypx);
     Convert(Xpx, Ypx, Xp, Yp);
   }
-} 
+}
 
 void V3d_View::BackgroundColor(const Quantity_TypeOfColor Type,Standard_Real& V1, Standard_Real& V2, Standard_Real& V3)const  {
  
@@ -2151,8 +2154,8 @@
 
   Standard_Real Wmin,Wmax,U,V,W ;
   Standard_Real Xmin,Ymin,Zmin,Xmax,Ymax,Zmax ;
-  // CAL 6/11/98
-  // Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;
+  /* CAL 6/11/98    */
+  /* Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;  */
   Standard_Integer Nstruct = MyView->NumberOfDisplayedStructures() ;
 
   if( Nstruct ) {
@@ -2188,8 +2191,8 @@
 }
 
 Standard_Integer V3d_View::MinMax(Standard_Real& Xmin, Standard_Real& Ymin, Standard_Real& Zmin, Standard_Real& Xmax, Standard_Real& Ymax, Standard_Real& Zmax) const {
-  // CAL 6/11/98
-  // Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;
+  /* CAL 6/11/98      */
+  /* Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;*/
   Standard_Integer Nstruct = MyView->NumberOfDisplayedStructures() ;
 
   if( Nstruct ) {
@@ -2206,8 +2209,8 @@
   Graphic3d_MapOfStructure MySetOfStructures;
   
   MyView->DisplayedStructures (MySetOfStructures);
-  //JMB  MySetOfStructures.Clear ();
-  //JMBMySetOfStructures.Union (()->Set ());
+  /*JMB  MySetOfStructures.Clear ();   */
+  /*JMBMySetOfStructures.Union (()->Set ());   */
   Nstruct = MySetOfStructures.Extent() ;
   
   Graphic3d_MapIteratorOfMapOfStructure MyIterator(MySetOfStructures) ;
@@ -2489,15 +2492,15 @@
   MyViewMapping.SetFrontPlaneDistance(size);
   MyViewMapping.SetBackPlaneDistance(-size);
 
-  // keep view plane at front plane distance
+  /* keep view plane at front plane distance    */
   MyViewMapping.SetViewPlaneDistance(MyType == V3d_PERSPECTIVE ? 0. : size);
 
-  // set window limits
+  /* set window limits   */
   Umin = Left; Umax = Right;
   Vmin = Bottom; Vmax = Top;
   MyViewMapping.SetWindowLimit(Left, Bottom, Right, Top);
 
-  // Update window center
+  /* Update window center */
   if ( MyType == V3d_PERSPECTIVE ) {
     Xrp = Yrp = 0.0;
   }
@@ -2508,10 +2511,11 @@
   MyViewMapping.SetProjectionReferencePoint(MyProjReferencePoint);
 
   MyView->SetViewMapping(MyViewMapping) ;
-//  SetZSize(0.);
+/*  SetZSize(0.);     */
   ImmediateUpdate();
 }
 
+
 Handle(Visual3d_View) V3d_View::View() const {
 
   return MyView ;
@@ -2527,6 +2531,7 @@
   return MyViewOrientation;
 }
 
+
 Standard_Boolean V3d_View::ScreenAxis( const Graphic3d_Vector &Vpn, const Graphic3d_Vector &Vup, Graphic3d_Vector &Xaxe, Graphic3d_Vector &Yaxe, Graphic3d_Vector &Zaxe) {
   Standard_Real Xpn,Ypn,Zpn,Xup,Yup,Zup ;
   Standard_Real dx1,dy1,dz1,dx2,dy2,dz2,xx,yy,zz ;
@@ -2570,14 +2575,14 @@
 Standard_Boolean V3d_View::Multiply (const TColStd_Array2OfReal& Left, const TColStd_Array2OfReal& Right, TColStd_Array2OfReal& Matrix) {
 
 Standard_Integer llr = Left.LowerRow ();
-//Standard_Integer lur = Left.UpperRow ();
+/*Standard_Integer lur = Left.UpperRow ();   */
 Standard_Integer llc = Left.LowerCol ();
 Standard_Integer luc = Left.UpperCol ();
 
 Standard_Integer rlr = Right.LowerRow ();
 Standard_Integer rur = Right.UpperRow ();
 Standard_Integer rlc = Right.LowerCol ();
-//Standard_Integer ruc = Right.UpperCol ();
+/*Standard_Integer ruc = Right.UpperCol (); */
 
 Standard_Integer mlr = Matrix.LowerRow ();
 Standard_Integer mur = Matrix.UpperRow ();
@@ -2588,7 +2593,7 @@
 
         InitMatrix (Result);
 
-        // Left et Right incompatibles
+        /* Left et Right incompatibles   */
         if (luc - llc + 1 != rur - rlr + 1)
                 return Standard_False;
 
@@ -2681,7 +2686,7 @@
   Graphic3d_Vertex PP ;
   Standard_Real X,Y,Z,XX,YY,ZZ ;
 
-  // CAL. S3892
+  /* CAL. S3892   */
 Standard_Integer lr, ur, lc, uc;
   lr    = Matrix.LowerRow ();
   ur    = Matrix.UpperRow ();
@@ -2709,7 +2714,7 @@
   Graphic3d_Vector VV ;
   Standard_Real X,Y,Z,XX,YY,ZZ ;
 
-  // CAL. S3892
+  /* CAL. S3892  */
 Standard_Integer lr, ur, lc, uc;
   lr    = Matrix.LowerRow ();
   ur    = Matrix.UpperRow ();
@@ -2782,15 +2787,15 @@
   Standard_Real Umin,Umax,Vmin,Vmax,Xrp,Yrp,Zrp ;
   Standard_Real DxvOld,DyvOld,DxvNew,DyvNew,RapOld,RapNew ;
   Standard_Integer Xpixel,Ypixel;
-  //Standard_Integer Xleft,Yup,Xright,Ylow ;
+  /*Standard_Integer Xleft,Yup,Xright,Ylow ;   */
   
   Viewer_BadValue_Raise_if( (Xmin == Xmax) || (Ymin == Ymax) ,
                           "V3d_View::FitAll, Window Size is NULL");
                         
   MyProjReferencePoint = MyViewMapping.ProjectionReferencePoint() ;
   MyProjReferencePoint.Coord(Xrp,Yrp,Zrp) ;
-  //aWindow->Position(Xleft,Yup,Xright,Ylow) ;
-  //DxvOld = Abs(Xright - Xleft) ; DyvOld = Abs(Yup - Ylow) ;
+  /*aWindow->Position(Xleft,Yup,Xright,Ylow) ; */
+  /*DxvOld = Abs(Xright - Xleft) ; DyvOld = Abs(Yup - Ylow) ;*/
   aWindow->Size(Xpixel,Ypixel);
   DxvOld = Xpixel; DyvOld = Ypixel;
 
@@ -2838,7 +2843,7 @@
   if( zRotationThreshold > 0. ) {
     Standard_Real dx = Abs(sx - rx/2.);
     Standard_Real dy = Abs(sy - ry/2.);
-//  if( dx > rx/3. || dy > ry/3. ) zRotation = Standard_True;
+/*  if( dx > rx/3. || dy > ry/3. ) zRotation = Standard_True;     */
     Standard_Real dd = zRotationThreshold * (rx + ry)/2.;
     if( dx > dd || dy > dd ) zRotation = Standard_True;
   }
@@ -2875,7 +2880,7 @@
 #else
   myImmediateUpdate = Standard_False;
   Rotate(dx/rx, dy/ry, 0., gx, gy, gz, Standard_False);
-  ZFitAll (Zmargin);		//Don't do that, perf improvment
+  ZFitAll (Zmargin);		/*Don't do that, perf improvment */
   myImmediateUpdate = Standard_True;
   ImmediateUpdate();
 #endif
@@ -2884,7 +2889,7 @@
 void V3d_View::SetAnimationModeOn () {
 #ifdef G003
   if ( MyAnimationFlags & V3d_FLAG_ANIMATION ) {
-    if( ComputedMode() ) {	// Deactivates computed mode during animation
+    if( ComputedMode() ) {	/* Deactivates computed mode during animation  */
       MyAnimationFlags |= V3d_FLAG_COMPUTATION;
       Standard_Boolean immediatUpdate = myImmediateUpdate;
       myImmediateUpdate = Standard_False;
@@ -2903,7 +2908,7 @@
  if ( MyAnimationFlags & V3d_FLAG_ANIMATION ) {
    MyView -> SetAnimationModeOff ();
    if ( MyAnimationFlags & V3d_FLAG_COMPUTATION ) {
-				// Reactivates computed mode after animation
+				/* Reactivates computed mode after animation */
      MyAnimationFlags &= ~V3d_FLAG_COMPUTATION;
      SetComputedMode(Standard_True);
    } else if( MyAnimationFlags & V3d_FLAG_DEGENERATION ) {
@@ -2935,7 +2940,7 @@
  else
   MyAnimationFlags &= ~V3d_FLAG_DEGENERATION;
 
-}  // end V3d_View :: SetAnimationMode
+}  /* end V3d_View :: SetAnimationMode    */
 
 Standard_Boolean V3d_View::AnimationMode( Standard_Boolean& isDegenerate ) const {
 
@@ -2985,13 +2990,13 @@
     Update ();
   }
 
-}  // end V3d_View :: SetComputedMode
+}  /* end V3d_View :: SetComputedMode  */
 
 Standard_Boolean V3d_View :: ComputedMode () const {
 
  return MyView -> ComputedMode ();
 
-}  // end V3d_View :: ComputedMode
+}  /* end V3d_View :: ComputedMode    */
 
 void V3d_View :: SetBackFacingModel (
                   const V3d_TypeOfBackfacingModel aModel
@@ -2999,13 +3004,13 @@
 
  MyView -> SetBackFacingModel ( Visual3d_TypeOfBackfacingModel(aModel) );
  Redraw();
-}  // end V3d_View :: SetBackFacingModel
+}  /* end V3d_View :: SetBackFacingModel   */
 
 V3d_TypeOfBackfacingModel V3d_View :: BackFacingModel () const {
 
  return V3d_TypeOfBackfacingModel(MyView -> BackFacingModel ());
 
-}  // end V3d_View :: BackFacingModel
+}  /* end V3d_View :: BackFacingModel */
 #endif
 
 Standard_Boolean V3d_View::TransientManagerBeginDraw(const Standard_Boolean DoubleBuffer,const Standard_Boolean RetainMode) const {
@@ -3047,7 +3052,7 @@
 }
 
 void V3d_View::Plot() {
-//  cout << "Appel a Plot de Visual3d_View" << endl;
+/*  cout << "Appel a Plot de Visual3d_View" << endl; */
   
   Viewer_BadValue_Raise_if( !MyPlotter.IsNull(), "view has no plotter");
 
@@ -3102,7 +3107,7 @@
     new WNT_WDriver (Handle(WNT_Window)::DownCast(MyWindow));
 #else
     new Xw_Driver (Handle(Xw_Window)::DownCast(MyWindow));
-#endif // WNT
+#endif /* WNT  */
   Quantity_Factor    aScale;
   Quantity_Length    thePixel;
   Quantity_Parameter theWWidth, theWHeight;
@@ -3115,18 +3120,18 @@
     if (aPlotScale == 0.) {
       aScale = Min (thePWidth / theWWidth, thePHeight / theWHeight);
     } else {
-      // To be changed !!!!!!!!!!!!!!!
+      /* To be changed !!!!!!!!!!!!!!! */
       aScale = Min (thePWidth / theWWidth, thePHeight / theWHeight);
     }
 
-    // Set default maps (color, type, etc) for plotter driver
+    /* Set default maps (color, type, etc) for plotter driver*/
     aPlotterDriver -> SetColorMap ( new Aspect_GenericColorMap () );
     aPlotterDriver -> SetTypeMap  ( new Aspect_TypeMap         () );
     aPlotterDriver -> SetWidthMap ( new Aspect_WidthMap        () );
     aPlotterDriver -> SetFontMap  ( new Aspect_FontMap         () );
     aPlotterDriver -> SetMarkMap  ( new Aspect_MarkMap         () );
 
-    // Set backgroung to white, unihiglight if any
+    /* Set backgroung to white, unihiglight if any   */
     Quantity_Parameter theRed, theGreen, theBlue;
     Handle(TColStd_HSequenceOfInteger) theFlags;
     Graphic3d_MapOfStructure  theStructures;
@@ -3148,7 +3153,7 @@
     }
     Redraw ();
 
-    // Dump the view
+    /* Dump the view */
     if (aPlotterDriver->IsKind(STANDARD_TYPE(PlotMgt_ImageDriver))) {
       aFileToDump  = aPlotterDriver->PlotFileName();
     } else {
@@ -3169,7 +3174,7 @@
       SetBackgroundColor (Quantity_TOC_RGB, theRed, theGreen, theBlue);
     Redraw ();
 
-    // Draw imagefile by plotter driver
+    /* Draw imagefile by plotter driver  */
     aPlotterDriver -> SetPixelSize (thePixel);
     aPlotterDriver -> BeginDraw ();
     aPlotterDriver -> DrawImageFile (
@@ -3189,7 +3194,7 @@
 #include <Graphic3d_GraphicDriver.hxx>
 #include <Visual3d_Layer.hxx>
 
-////////////////////////////////////////////////////////////////
+/*//////////////////////////////////////////////////////////////*/
 Standard_Boolean V3d_View::Dump ( const Standard_CString aFile )
 {
 Standard_Boolean isDone;
@@ -3205,16 +3210,16 @@
   return isDone;
 }
 
-////////////////////////////////////////////////////////////////
+/*///////////////////////////////////////////////////////////////*/
 Standard_Boolean V3d_View::Dump ( const Standard_CString aFile,
                       const Aspect_FormatOfSheetPaper aFormat)
 {
 Standard_Boolean isDone = Standard_False;
-  // convert Aspect_FormatOfSheetPaper size to pixel ...
+  /* convert Aspect_FormatOfSheetPaper size to pixel ...*/
   Quantity_Length theSPWidth, theSPHeight;
   Aspect::ValuesOfFOSP ( aFormat, theSPWidth, theSPHeight );
 
-  // adjusting to the ratio width/height ...
+  /* adjusting to the ratio width/height ...*/
   Quantity_Length theWinWidth, theWinHeight;
   MyWindow->MMSize ( theWinWidth, theWinHeight );
   Standard_Integer thePixelWidth, thePixelHeight;
@@ -3236,18 +3241,18 @@
     Xw_PixMap aBitmap ( MyWindow, thePixelWidth, thePixelHeight );
 #endif
 
-    // add bitmap ID and size to the MyCView structure ...
+    /* add bitmap ID and size to the MyCView structure ...*/
     cView->DefBitmap.bitmap = aBitmap.PixmapID();
     cView->DefBitmap.width  = thePixelWidth;
     cView->DefBitmap.height = thePixelHeight;
 
     Redraw ();
 
-    // deactivate the bitmap ID in the MyCView structure ...
+    /* deactivate the bitmap ID in the MyCView structure ...*/
     cView->DefBitmap.bitmap = Aspect_Handle(NULL);
     cView->DefBitmap.width  = 0;
     cView->DefBitmap.height = 0;
-#endif // IMP100701
+#endif /* IMP100701*/
 
     Standard_Real gammaValue = 1.0; 
     OSD_Environment envGamma("CSF_GAMMA_CORRECTION");
@@ -3258,7 +3263,7 @@
   }
   return isDone;
 }
-#endif	//G004
+#endif	/*G004*/
 
 ////////////////////////////////////////////////////////////////
 Handle(Aspect_PixMap) V3d_View::ToPixMap (const Standard_Integer aWidth,
@@ -3273,26 +3278,26 @@
     theBitmap = new Xw_PixMap ( MyWindow, aWidth, aHeight, aCDepth );
 #endif
 
-    //szv: save mapping
+    /*szv: save mapping*/
     Visual3d_ViewMapping prevMapping = MyView->ViewMapping();
 
-    //szv: get mapping frame
+    /*szv: get mapping frame*/
     Standard_Real PUmin, PVmin, PUmax, PVmax;
     prevMapping.WindowLimit(PUmin,PVmin,PUmax,PVmax);
 
-    //szv: calculate expansion
+    /*szv: calculate expansion*/
     Standard_Real Umin = PUmin, Vmin = PVmin, Umax = PUmax, Vmax = PVmax;
     Standard_Real oldWidth = (PUmax - PUmin), oldHeight = (PVmax - PVmin);
     Standard_Real newWidth = (oldHeight * aWidth) / aHeight;
     if (newWidth < oldWidth) {
       Standard_Real newHeight = (oldWidth * aHeight) / aWidth;
-      // Expand height
+      /* Expand height*/
       Standard_Real delta = 0.5 * (newHeight - oldHeight);
       Vmin = PVmin - delta;
       Vmax = PVmax + delta;
     }
     else {
-      // Expand width
+      /* Expand width*/
       Standard_Real delta = 0.5 * (newWidth - oldWidth);
       Umin = PUmin - delta;
       Umax = PUmax + delta;
@@ -3300,7 +3305,7 @@
 
     Graphic3d_CView* cView = (Graphic3d_CView*)MyView->CView();
 
-    // add bitmap ID and size to the MyCView structure ...
+    /* add bitmap ID and size to the MyCView structure ...*/
     Standard_Integer aWi, anHe;
     theBitmap->Size ( aWi, anHe );
     cView->DefBitmap.bitmap = theBitmap->PixmapID();
@@ -3308,17 +3313,17 @@
     cView->DefBitmap.height = anHe;
     cView->DefBitmap.depth = theBitmap->Depth();
 
-    //szv: apply expanded mapping
+    /*szv: apply expanded mapping*/
     MyViewMapping.SetWindowLimit(Umin,Vmin,Umax,Vmax);
     MyView->SetViewMapping(MyViewMapping);
 
     Redraw ( );
 
-    //szv: restore mapping
+    /*szv: restore mapping*/
     MyViewMapping = prevMapping;
     MyView->SetViewMapping(prevMapping);
 
-    // deactivate the bitmap ID in the MyCView structure ...
+    /* deactivate the bitmap ID in the MyCView structure ...*/
     cView->DefBitmap.bitmap  = Aspect_Handle(NULL);
     cView->DefBitmap.width  = 0;
     cView->DefBitmap.height = 0;
diff -Naur OpenCASCADE6.3.0/ros/src/ViewerTest/ViewerTest_ViewerCommands.cxx OpenCASCADE6.3.0sp6/ros/src/ViewerTest/ViewerTest_ViewerCommands.cxx
--- OpenCASCADE6.3.0/ros/src/ViewerTest/ViewerTest_ViewerCommands.cxx	2008-08-15 15:57:34.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/ViewerTest/ViewerTest_ViewerCommands.cxx	2009-10-03 01:04:52.000000000 +0200
@@ -1411,6 +1411,23 @@
   return 0;
 }
 
+//==============================================================================
+//function : VTestZBuffTrihedron
+//purpose  : Displays a V3d_ZBUFFER'ed trihedron at the bottom left corner of the view
+//==============================================================================
+
+static int VTestZBuffTrihedron(Draw_Interpretor& di, Standard_Integer argc, const char** argv)
+{
+  Handle(V3d_View) V3dView = ViewerTest::CurrentView();
+  if ( V3dView.IsNull() ) return 1;
+
+  // Set up default trihedron parameters
+  V3dView->ZBufferTriedronSetup();
+  V3dView->TriedronDisplay( Aspect_TOTP_LEFT_LOWER, Quantity_NOC_WHITE, 0.1, V3d_ZBUFFER );
+  V3dView->ZFitAll();
+  return 0;
+}
+
 //=======================================================================
 //function : ViewerCommands
 //purpose  :
@@ -1453,5 +1470,8 @@
   theCommands.Add("vscale",
 		  "vscale          : vscale X Y Z",
 		  __FILE__,VScale,group);
+  theCommands.Add("vzbufftrihedron",
+		  "vzbufftrihedron : Displays a V3d_ZBUFFER'ed trihedron at the bottom left corner of the view",
+		  __FILE__,VTestZBuffTrihedron,group);
 
 }
diff -Naur OpenCASCADE6.3.0/ros/src/Visual3d/Visual3d_View.cxx OpenCASCADE6.3.0sp6/ros/src/Visual3d/Visual3d_View.cxx
--- OpenCASCADE6.3.0/ros/src/Visual3d/Visual3d_View.cxx	2008-08-22 15:17:03.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/Visual3d/Visual3d_View.cxx	2009-10-03 01:04:52.000000000 +0200
@@ -59,21 +59,21 @@
 
 ************************************************************************/
 
-#define BUC60572        //GG_03-08-99    Add protection on Zclipping & Zcueing planes
-//              positions.
+#define BUC60572        /*GG_03-08-99    Add protection on Zclipping & Zcueing planes */
+/*              positions.      */
 
-#define BUC60570        //GG 14-09-99 Don't activates lighting
-//                      when the view shading model is NONE.
+#define BUC60570        /*GG 14-09-99 Don't activates lighting
+                      when the view shading model is NONE.   */
 
-#define GER61454        //GG 14-09-99 Activates model clipping planes
+#define GER61454        /*GG 14-09-99 Activates model clipping planes  */
 
-#define IMP140100       //GG14-01-00 Add ViewManager( ) method
+#define IMP140100       /*GG14-01-00 Add ViewManager( ) method  */
 
-#define G003            //EUG 30-09-00 Degeneration management
-//                                     Backfacing management
+#define G003            /*EUG 30-09-00 Degeneration management
+                                     Backfacing management    */
 
-#define RIC120302       //GG Add a NEW SetWindow method which enable
-//                      to connect a graphic widget and context to OGL.
+#define RIC120302       /*GG Add a NEW SetWindow method which enable
+                      to connect a graphic widget and context to OGL.  */
 
 #define  BUC61044    /* 25/10/01 SAV ; added functionality to control gl depth testing
                         from higher API */
@@ -110,7 +110,7 @@
 #include <windows.h>
 #endif
 
-// for the class
+/* for the class  */
 #include <Visual3d_View.ixx>
 #include <Visual3d_View.pxx>
 #include <Visual3d_DepthCueingDefinitionError.hxx>
@@ -153,13 +153,13 @@
 # include <Xw_Window.hxx>
 #else
 # include <WNT_Window.hxx>
-#endif  // WNT
+#endif  /* WNT    */
 
-//-Aliases
+/*-Aliases*/
 
-//-Global data definitions
+/*-Global data definitions  */
 
-//-Constructors
+/*-Constructors */
 
 Visual3d_View::Visual3d_View (const Handle(Visual3d_ViewManager)& AManager):
 MyContext (),
@@ -222,14 +222,14 @@
         MyCView.Orientation.ViewScaleY                  = float (Sy);
         MyCView.Orientation.ViewScaleZ                  = float (Sz);
 
-        // NKV : 23/07/07 - Define custom MODELVIEW matrix
+        /* NKV : 23/07/07 - Define custom MODELVIEW matrix   */
         MyCView.Orientation.IsCustomMatrix = 0;
         memset( (float*)MyCView.Orientation.ModelViewMatrix, 0, 16*sizeof( float ) ); 
         MyCView.Orientation.ModelViewMatrix[0][0] =
         MyCView.Orientation.ModelViewMatrix[1][1] =
         MyCView.Orientation.ModelViewMatrix[2][2] =
         MyCView.Orientation.ModelViewMatrix[3][3] = 1.;
-        //
+                /**/
 
 Standard_Real um, vm, uM, vM;
 
@@ -250,14 +250,14 @@
         MyCView.Mapping.WindowLimit.uM  = float (uM);
         MyCView.Mapping.WindowLimit.vM  = float (vM);
 
-        // NKV : 23/07/07 - Define custom MODELVIEW matrix
+        /* NKV : 23/07/07 - Define custom MODELVIEW matrix  */
         MyCView.Mapping.IsCustomMatrix = 0;
         memset( (float*)MyCView.Mapping.ProjectionMatrix, 0, 16*sizeof( float ) ); 
         MyCView.Mapping.ProjectionMatrix[0][0] =
         MyCView.Mapping.ProjectionMatrix[1][1] =
         MyCView.Mapping.ProjectionMatrix[2][2] =
         MyCView.Mapping.ProjectionMatrix[3][3] = 1.;
-        //
+        /**/
 
         MyCView.Context.ZBufferActivity = -1;
 
@@ -273,7 +273,7 @@
         MyCView.IsDegeneratesPrev = 0;
         ComputedModeIsActive      = Standard_False;
         MyCView.Backfacing        = 0;
-#endif  // G003
+#endif  /* G003   */
 
         MyCView.DefBitmap.bitmap = 0;
         MyCView.ptrUnderLayer = 0;
@@ -350,8 +350,8 @@
         MyCView.Orientation.ViewScaleX                  = float (Sx);
         MyCView.Orientation.ViewScaleY                  = float (Sy);
         MyCView.Orientation.ViewScaleZ                  = float (Sz);
-
-        // NKV : 23/07/07 - Define custom MODELVIEW matrix
+   
+        /* NKV : 23/07/07 - Define custom MODELVIEW matrix    */
         if (MyViewOrientation.IsCustomMatrix()) {
           MyCView.Orientation.IsCustomMatrix = 1;
           for ( i = 0; i < 4; i++)
@@ -366,7 +366,7 @@
           MyCView.Orientation.ModelViewMatrix[2][2] =
           MyCView.Orientation.ModelViewMatrix[3][3] = 1.;
         }
-        //
+        /**/
 
 Standard_Real um, vm, uM, vM;
 
@@ -387,7 +387,7 @@
         MyCView.Mapping.WindowLimit.uM  = float (uM);
         MyCView.Mapping.WindowLimit.vM  = float (vM);
 
-        // NKV : 23/07/07 - Define custom MODELVIEW matrix
+        /* NKV : 23/07/07 - Define custom MODELVIEW matrix  */
         if (MyViewMapping.IsCustomMatrix()) {
           MyCView.Mapping.IsCustomMatrix = 1;
           for ( i = 0; i < 4; i++)
@@ -402,8 +402,8 @@
           MyCView.Mapping.ProjectionMatrix[2][2] =
           MyCView.Mapping.ProjectionMatrix[3][3] = 1.;
         }
-        //
-
+        /**/
+   
         MyCView.Context.ZBufferActivity = -1;
 
         MyMatOfMapIsModified    = Standard_True;
@@ -415,7 +415,7 @@
         MyCView.IsDegenerates     = 0;
         MyCView.IsDegeneratesPrev = 0;
         ComputedModeIsActive      = Standard_False;
-#endif  // G003
+#endif  /* G003  */
 
         MyCView.DefBitmap.bitmap = 0;
         MyCView.ptrUnderLayer = 0;
@@ -431,10 +431,10 @@
 
 }
 
-//-Destructors
+/*-Destructors */
 
-//-Methods, in order
-// RIC120302
+/*-Methods, in order*/
+/* RIC120302  */
 void Visual3d_View::SetWindow (const Handle(Aspect_Window)&      AWindow,
                                const Aspect_RenderingContext     AContext,
                                const Aspect_GraphicCallbackProc& ADisplayCB,
@@ -486,8 +486,8 @@
 
 Standard_Integer Width, Height;
         AWindow->Size (Width, Height);
-
-        MyCView.DefWindow.dx    = float( Width );
+	
+        MyCView.DefWindow.dx    = float( Width ); 
         MyCView.DefWindow.dy    = float( Height );
 
 Standard_Real R, G, B;
@@ -628,7 +628,7 @@
         MyViewMapping.WindowLimit(Umin,Vmin,Umax,Vmax) ;
         Xc      = (Umin + Umax)/2. ; Yc = (Vmin + Vmax)/2. ;
         Dxv     = Umax - Umin ; Dyv     = Vmax - Vmin ;
-        if( Dxw > 0 && Dyw > 0 ) Rap = (Standard_Real)Dyw/(Standard_Real)Dxw ;
+	   if( Dxw > 0 && Dyw > 0 ) Rap = (Standard_Real)Dyw/(Standard_Real)Dxw;
         if( Rap > 0.0 ) {
 
             if( Dxv <= Dyv ) 
@@ -665,11 +665,11 @@
 
             // Mise a jour avant le SetViewMapping.
 
-            MyCView.DefWindow.dx        = float( Dxw );
-            MyCView.DefWindow.dy        = float( Dyw );
+            MyCView.DefWindow.dx        = float( Dxw ); 
+            MyCView.DefWindow.dy        = float( Dyw ); 
 
             SetViewMapping (MyViewMapping);
-//          SetViewMappingDefault ();
+            // SetViewMappingDefault ();
             // FMN+ Mise a jout Ratio pour le MyViewMappingReset
             
             MyViewMappingReset.WindowLimit(Umin,Vmin,Umax,Vmax) ;
@@ -1109,7 +1109,7 @@
         MyCView.Orientation.ViewScaleY                  = float (Sy);
         MyCView.Orientation.ViewScaleZ                  = float (Sz);
 
-        CustomIsModified = 
+	  CustomIsModified = 
           MyCView.Orientation.IsCustomMatrix != MyViewOrientation.IsCustomMatrix();
         MyCView.Orientation.IsCustomMatrix = MyViewOrientation.IsCustomMatrix();
         if ( MyViewOrientation.IsCustomMatrix() ) {
@@ -1121,14 +1121,14 @@
               MyCView.Orientation.ModelViewMatrix[i][j] = MyViewOrientation.MyModelViewMatrix->Value(i,j);
             }
         }
-
+              
 #ifdef TRACE_TRSF
 cout << "Visual3d_View::SetViewOrientation\n";
-        if (VUPIsModified || VRPIsModified || VRUIsModified || CustomIsModified)
-                cout <<   "VUPIsModified : " << VUPIsModified
-                     << ", VRPIsModified : " << VRPIsModified
-                     << ", VRUIsModified : " << VRUIsModified 
-                     << ", CustomIsModified : " << CustomIsModified << "\n" << flush;
+         if (VUPIsModified || VRPIsModified || VRUIsModified || CustomIsModified)
+              cout <<   "VUPIsModified : " << VUPIsModified
+                   << ", VRPIsModified : " << VRPIsModified
+                   << ", VRUIsModified : " << VRUIsModified 
+                   << ", CustomIsModified : " << CustomIsModified << "\n" << flush;
         else
                 cout << "no modification\n" << flush;
 #endif
@@ -1297,14 +1297,14 @@
         MyCView.Mapping.WindowLimit.uM  = float (uM);
         MyCView.Mapping.WindowLimit.vM  = float (vM);
 
-        MyCView.Mapping.IsCustomMatrix = MyViewMapping.IsCustomMatrix();
+	   MyCView.Mapping.IsCustomMatrix = MyViewMapping.IsCustomMatrix();
         if (MyViewMapping.IsCustomMatrix()) {
           Standard_Integer i, j;
           for (i = 0; i < 4; i++)
             for (j = 0; j < 0; j++)
               MyCView.Mapping.ProjectionMatrix[i][j] = MyViewMapping.MyProjectionMatrix->Value(i,j);
         }
-
+	
         MyMatOfMapIsModified    = Standard_True;
         MyMatOfMapIsEvaluated   = Standard_False;
 
@@ -1365,7 +1365,7 @@
         MyCView.Mapping.WindowLimit.uM  = float (uM);
         MyCView.Mapping.WindowLimit.vM  = float (vM);
 
-        MyCView.Mapping.IsCustomMatrix = MyViewMapping.IsCustomMatrix();
+	  MyCView.Mapping.IsCustomMatrix = MyViewMapping.IsCustomMatrix();
         if (MyViewMapping.IsCustomMatrix()) {
           Standard_Integer i, j;
           for (i = 0; i < 4; i++)
@@ -1605,11 +1605,11 @@
 
 }
 
-void Visual3d_View::DisplayedStructures (Graphic3d_MapOfStructure& SG) const 
+void Visual3d_View::DisplayedStructures (Graphic3d_MapOfStructure& SG) const
 {
 
   if (IsDeleted ()) return;
-
+  
   Graphic3d_MapIteratorOfMapOfStructure Iterator (MyDisplayedStructure);
 
   while (Iterator.More ()) {
@@ -1647,7 +1647,7 @@
                  * la vue directement, si la structure n'est pas deja
                  * affichee et si la vue l'accepte dans son contexte.
                  */
-
+          
 		Visual3d_TypeOfAnswer Answer;
                 Graphic3d_MapOfStructure Map;
                 MyViewManager->DisplayedStructures(Map);
@@ -1718,7 +1718,8 @@
                  * effacee et si la vue l'accepte dans son contexte.
                  */
 
-		Visual3d_TypeOfAnswer Answer;
+           
+          Visual3d_TypeOfAnswer Answer;
                 Graphic3d_MapOfStructure Map;
                 MyViewManager->DisplayedStructures(Map);
                 Graphic3d_MapIteratorOfMapOfStructure it(Map);
@@ -2083,10 +2084,10 @@
                 Index = 0;
         }
 
-	Visual3d_TypeOfAnswer Answer = AcceptDisplay (AStructure);
+      Visual3d_TypeOfAnswer Answer = AcceptDisplay (AStructure);
 
 #ifdef TRACE_DISPLAY
-	Standard_Integer StructId = AStructure->Identification ();
+      	Standard_Integer StructId = AStructure->Identification ();
         cout << "Visual3d_View" << MyCView.ViewId << "::Display ("
              << StructId << ");\n";
         cout << flush;
@@ -2094,8 +2095,8 @@
 
         if (Answer == Visual3d_TOA_NO) {
 #ifdef TRACE_DISPLAY
-                cout << "Answer : Visual3d_TOA_NO\n";
-                cout << flush;
+	          cout << "Answer : Visual3d_TOA_NO\n";
+               cout << flush;
 #endif
                 return;
         }
@@ -2880,24 +2881,25 @@
         	APX     = ( APX + 1 ) * 0.5 * (uM - um) + um;
         	APY     = ( APY + 1 ) * 0.5 * (vM - vm) + vm;
         } else {
-        	Ratio   = (uM - um) / (vM - vm);
-        	if (Ratio >= 1.0)
-        		APY *= Ratio;
-        	else
-        		APX /= Ratio;
-
-        	/*
-        	* Les coordonnees de APX, APY, APZ sont decrites dans
-        	* l'espace [0-1]x[0-1]x[0-1].
-        	* Il faut transformer x et y dans le window space.
-        	* Il faut transformer z dans l'espace du back et front
-        	* plane, en pensant aux plans de clipping.
-        	* Ces plans de z clipping sont definis entre 0 et 1.
-        	*/
-            APX     = APX * (uM - um) + um;
-            APY     = APY * (vM - vm) + vm;
-        }		
-        APZ     = APZ * (fpd - bpd) + bpd;
+        Ratio   = (uM - um) / (vM - vm);
+        if (Ratio >= 1.0)
+            APY *= Ratio;
+        else
+            APX /= Ratio;
+
+        /*
+         * Les coordonnees de APX, APY, APZ sont decrites dans
+         * l'espace [0-1]x[0-1]x[0-1].
+         * Il faut transformer x et y dans le window space.
+         * Il faut transformer z dans l'espace du back et front
+         * plane, en pensant aux plans de clipping.
+         * Ces plans de z clipping sont definis entre 0 et 1.
+        */
+
+        APX     = APX * (uM - um) + um;
+        APY     = APY * (vM - vm) + vm;
+     }
+     APZ     = APZ * (fpd - bpd) + bpd;
 }
  
 Standard_Integer Visual3d_View::Identification () const {
@@ -3094,7 +3096,7 @@
                         MyCOMPUTEDSequence.Value (Index)->Identification ();
 #ifdef TRACE_COMP
 	Standard_Integer StructId = AStructure->Identification ();
-        cout << "La structure " << StructId
+       cout << "La structure " << StructId
              << " calculee, dans la view "
              << Identification () << ", par la structure "
              << OldStructId << " est recalculee.\n";
diff -Naur OpenCASCADE6.3.0/ros/src/WNT/WNT_Window.cdl OpenCASCADE6.3.0sp6/ros/src/WNT/WNT_Window.cdl
--- OpenCASCADE6.3.0/ros/src/WNT/WNT_Window.cdl	2005-08-26 18:28:43.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/WNT/WNT_Window.cdl	2009-10-03 01:04:53.000000000 +0200
@@ -16,6 +16,12 @@
 	--  Warning: The position and size for the creation of the window
 	--	    are defined in Device Screen Unit (DSU)
 	--	    floating [0,1] space.
+        --         
+	--          As 3D view window is the main purpose of this class,
+	--          and 3D view does not need its background to be drawn
+	--          by the system, by default the window background is not drawn.
+	--          This can be overridden by calling ClearFlags( WDF_NOERASEBKGRND ).
+	--          See also WNT_WndProc.cxx and InterfaceGraphic_WNT.hxx.
 
  uses
 
@@ -335,11 +341,15 @@
      is static;
      	---Level:   Public
      	---Purpose: Sets user defined flags in the extra window data area.
+	--          Supported flags WDF_* are listed in InterfaceGraphic_WNT.hxx
+	--          In particular, the window backround can be turned off using this method.
 
     ResetFlags ( me : mutable; aFlags : Integer from Standard )
      is static;
      	---Level:   Public
     	---Purpose: Reset specified flags in the extra window data area.
+	--          Supported flags WDF_* are listed in InterfaceGraphic_WNT.hxx
+	--          In particular, the window backround can be turned on using this method.
 
     
  	----------------------------
diff -Naur OpenCASCADE6.3.0/ros/src/WNT/WNT_Window.cxx OpenCASCADE6.3.0sp6/ros/src/WNT/WNT_Window.cxx
--- OpenCASCADE6.3.0/ros/src/WNT/WNT_Window.cxx	2008-07-04 17:36:55.000000000 +0200
+++ OpenCASCADE6.3.0sp6/ros/src/WNT/WNT_Window.cxx	2009-10-03 01:04:53.000000000 +0200
@@ -67,13 +67,13 @@
                const Aspect_Handle                aMenu,
                const Standard_Address             aClientStruct
                   ) : Aspect_Window ( aDevice ), myWClass ( aClass )
-{
+{	
   int   x, y, w, h, px, py, pw, ph;
   DWORD dwStyle = aStyle;
   const Handle( WNT_GraphicDevice )& dev = Handle( WNT_GraphicDevice ) ::
                                            DownCast ( MyGraphicDevice );
 
-  if ( Xc < 0. || Xc > 1. || Yc < 0. || Yc > 1. ||
+   if ( Xc < 0. || Xc > 1. || Yc < 0. || Yc > 1. ||
        aWidth <= 0. || aHeight <= 0. )
 
   Aspect_WindowDefinitionError :: Raise ( "Coordinate(s) out of range" );
@@ -150,8 +150,7 @@
   myHPixmap       = 0;
   myHParentWindow = aParent;
   myWndProc       = myWClass -> WndProc ();
-  myHParentWindow = aParent;
-
+  myHParentWindow = aParent;	
   SetBackground ( aBackColor );
 #ifndef _WIN64
   SetWindowLong (  ( HWND )myHWindow, GWL_WNDPROC,  ( LONG )WNT_WndProc   );
@@ -177,6 +176,11 @@
   myImages = new WNT_ImageManager ( this );
   myFormat = WNT_TOI_XWD;
 
+    /* Bug OCC20596 */
+	SetFlags(WDF_NOERASEBKGRND);
+ 
+
+
 }  // end constructor
 //***//
 //************************* Constructor **********************************//
@@ -189,6 +193,9 @@
 
  doCreate ( aDevice, aHandle, aBackColor );
 
+	/* Bug OCC20596 */
+	SetFlags(WDF_NOERASEBKGRND);
+
 }  // end constructor
 //***//
 //************************* Constructor **********************************//
@@ -204,6 +211,9 @@
 
  doCreate ( aDevice, aHandle, aBackColor );
 
+ 	/* Bug OCC20596 */
+	SetFlags(WDF_NOERASEBKGRND);
+
 }  // end constructor
 //***//
 //***************************** Destroy **********************************//
